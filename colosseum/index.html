<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>⚔️ AI 콜로세움 — PIXEL DEATH ARENA</title>
<style>
@font-face{font-family:'NeoDGM';src:url('/static/fonts/neodgm.woff2') format('woff2');font-display:swap}
*{margin:0;padding:0;box-sizing:border-box}
body{background:#000;color:#FCC88E;font-family:'NeoDGM',monospace;overflow:hidden;height:100vh;display:flex;align-items:center;justify-content:center}
canvas{display:block;image-rendering:pixelated;image-rendering:crisp-edges}
</style>
</head>
<body>
<canvas id="G"></canvas>
<script>
// ═══════════════════════════════════════════════════════════════
//  AI 콜로세움 — PIXEL DEATH ARENA
//  384×216 base resolution, ×3 nearest-neighbor scaling
//  All coordinates INTEGER only. No alpha, blur, gradient.
// ═══════════════════════════════════════════════════════════════

const C = document.getElementById('G');
const X = C.getContext('2d');
const W = 384, H = 216;
C.width = W; C.height = H;
X.imageSmoothingEnabled = false;

const SCALE = 3;
function resize() {
  // Integer scale, nearest-neighbor
  const maxS = Math.max(1, Math.min(
    Math.floor(innerWidth / W),
    Math.floor(innerHeight / H)
  ));
  const s = Math.max(SCALE, maxS);
  C.style.width = (W * s) + 'px';
  C.style.height = (H * s) + 'px';
}
resize();
addEventListener('resize', resize);

// ─── PALETTE ───
const PAL = {
  bg1: '#0a0810', bg2: '#120818', bg3: '#1a1225',
  stone1: '#1a1020', stone2: '#231830', stone3: '#2a1e35',
  floor1: '#1a1225', floor2: '#231830',
  blood1: '#cc2222', blood2: '#661111',
  spark: '#ffdd88', sparkHi: '#ffffff',
  venom: '#22aa44', venomDk: '#115522',
  ice: '#55aacc', iceDk: '#336688',
  fire1: '#ff6622', fire2: '#cc3300', fireHi: '#ffcc00',
  gold: '#d4af5a', cream: '#FCC88E',
  hpG: '#22cc44', hpY: '#ccaa22', hpR: '#cc2222',
  white: '#ffffff', black: '#000000',
};

// ─── CONSTANTS ───
const GROUND_Y = 186;       // feet position (384×216 scale)
const CHAR_SCALE = 3;       // 64px × 3 = 192px on internal canvas
const GRAVITY = 0.7;
const STAGE_LEFT = 20;
const STAGE_RIGHT = W - 20;
const ATTACK_RANGE = 80;    // scaled down from 800px canvas
const CLOSE_RANGE = 60;

// ─── FIGHTERS ───
const FIGHTERS = [
  {id:'bloodfang',   name:'블러드팡',      weapon:'도끼',   color:'#cc3333', style:'rush',    atk:18,def:8, spd:12,hp:1000,special:'지옥참격',  super:'블러드레인'},
  {id:'ironclaw',    name:'아이언클로',    weapon:'철퇴',   color:'#8888aa', style:'grapple', atk:14,def:16,spd:7, hp:1300,special:'아이언월',  super:'크러셔임팩트'},
  {id:'shadowblade', name:'쉐도우블레이드',weapon:'쌍단검', color:'#33aa77', style:'mixup',   atk:20,def:5, spd:18,hp:850, special:'환영참',    super:'무영난무'},
  {id:'berserker',   name:'버서커',        weapon:'카타나', color:'#dd6633', style:'rush',    atk:22,def:4, spd:16,hp:900, special:'발광참',    super:'아수라참영진'},
  {id:'bonecrusher', name:'본크러셔',      weapon:'해머',   color:'#886644', style:'grapple', atk:17,def:14,spd:5, hp:1250,special:'어스퀘이크',super:'메테오해머'},
  {id:'venomqueen',  name:'베놈퀸',        weapon:'독검',   color:'#22aa66', style:'zone',    atk:12,def:10,spd:14,hp:950, special:'독무화',    super:'데스블룸'},
  {id:'hellfire',    name:'헬파이어',      weapon:'화염검', color:'#ff8833', style:'mixup',   atk:20,def:7, spd:12,hp:950, special:'화염선풍',  super:'인페르노'},
  {id:'frostbite',   name:'프로스트바이트',weapon:'빙결창', color:'#55aacc', style:'zone',    atk:13,def:12,spd:10,hp:1100,special:'빙결진',    super:'절대영도'},
];

const FATALITIES = ['head_off','bisect','explode','impale','spine_rip','dissolve'];
const FATALITY_KR = {head_off:'참수',bisect:'양단',explode:'폭사',impale:'관통',spine_rip:'척추적출',dissolve:'용해'};

const ASSET = '/colosseum/assets/';
const imgCache = {};
let totalLoad = 0, loaded = 0;

function loadImg(p) {
  if (imgCache[p]) return Promise.resolve(imgCache[p]);
  totalLoad++;
  return new Promise(res => {
    const img = new Image();
    img.onload = () => { imgCache[p] = img; loaded++; res(img); };
    img.onerror = () => { loaded++; res(null); };
    img.src = p;
  });
}

function preloadFighter(f) {
  const b = ASSET + f.id + '/';
  const ps = [];

  // New spritesheet frames (preferred)
  const newFrames = {
    idle: 4, walk_fwd: 4, walk_back: 4,
    light_atk: 4, heavy_atk: 4, special_atk: 4,
    hit: 4, block: 4, death: 4, victory: 4
  };
  for (const [anim, count] of Object.entries(newFrames)) {
    for (let i = 0; i < count; i++) ps.push(loadImg(b + anim + '_' + i + '.png'));
  }

  // Legacy fallback frames
  ps.push(loadImg(b + 'idle.png'));
  for (let i = 0; i < 2; i++) ps.push(loadImg(b + 'walk_' + i + '.png'));
  for (let i = 0; i < 3; i++) ps.push(loadImg(b + 'attack_' + i + '.png'));
  for (const a of ['hit','block','death','victory']) ps.push(loadImg(b + a + '.png'));
  for (const ft of FATALITIES)
    for (let i = 0; i < 4; i++) ps.push(loadImg(b + 'fatal_' + ft + '_' + i + '.png'));
  return Promise.all(ps);
}

// ─── STATE ───
let scene = 'title', tick = 0, roundNum = 1, p1Wins = 0, p2Wins = 0;
let p1, p2, f1Data, f2Data;
let announceText = '', announceTimer = 0, announceSize = 24;
let slowmo = 0, flashFrames = 0, flashColor = PAL.white;
let bloodStains = [], particles = [], dmgTexts = [], slashFX = [];
let selectP1 = 0, selectP2 = 1, selectTimer = 0;
let shakeDur = 0, shakeX = 0, shakeY = 0;
let gameTimer = 99;
let timerTick = 0;

// ─── FIGHTER ───
class Fighter {
  constructor(data, side) {
    this.d = data;
    this.side = side;
    this.x = side === 'left' ? 90 : W - 90;
    this.y = GROUND_Y;
    this.vx = 0;
    this.vy = 0;
    this.hp = data.hp;
    this.maxHp = data.hp;
    this.pow = 0;
    this.state = 'idle';
    this.frame = 0;
    this.frameTick = 0;
    this.facing = side === 'left' ? 1 : -1;
    this.cooldown = 0;
    this.hitstun = 0;
    this.blockstun = 0;
    this.comboCount = 0;
    this.airborne = false;
    this.dead = false;
    this.frozen = 0;
    this.poison = 0;
    this.armor = 0;
    this.rage = 0;
    this.fatalType = null;
    this.fatalFrame = 0;
    this.enemy = null;
    this.lastAction = '';
    this.hitFlash = 0; // frames remaining for hit flash overlay
  }

  get alive() { return this.hp > 0 && !this.dead; }
  get canAct() { return this.hitstun <= 0 && this.blockstun <= 0 && this.cooldown <= 0 && this.frozen <= 0 && !this.dead && this.state !== 'fatality' && this.state !== 'death'; }
  get dist() { return Math.abs(this.x - this.enemy.x); }

  faceEnemy() { if (this.enemy) this.facing = this.x < this.enemy.x ? 1 : -1; }

  getImg() {
    const b = ASSET + this.d.id + '/';

    // Try new frame names first, fall back to legacy
    if (this.state === 'fatality')
      return imgCache[b + 'fatal_' + this.fatalType + '_' + Math.min(this.fatalFrame, 3) + '.png'];

    if (this.state === 'idle') {
      const newImg = imgCache[b + 'idle_' + (this.frame % 4) + '.png'];
      return newImg || imgCache[b + 'idle.png'];
    }
    if (this.state === 'walk' || this.state === 'dash') {
      const newImg = imgCache[b + 'walk_fwd_' + (this.frame % 4) + '.png'];
      return newImg || imgCache[b + 'walk_' + (this.frame % 2) + '.png'];
    }
    if (this.state === 'attack') {
      const newImg = imgCache[b + 'light_atk_' + Math.min(this.frame, 3) + '.png'];
      return newImg || imgCache[b + 'attack_' + Math.min(this.frame, 2) + '.png'];
    }
    if (this.state === 'special') {
      const newImg = imgCache[b + 'heavy_atk_' + Math.min(this.frame, 3) + '.png'];
      return newImg || imgCache[b + 'attack_' + Math.min(this.frame, 2) + '.png'];
    }
    if (this.state === 'super') {
      const newImg = imgCache[b + 'special_atk_' + Math.min(this.frame, 3) + '.png'];
      return newImg || imgCache[b + 'attack_' + Math.min(this.frame, 2) + '.png'];
    }
    if (this.state === 'hit') {
      const newImg = imgCache[b + 'hit_' + Math.min(this.frame, 3) + '.png'];
      return newImg || imgCache[b + 'hit.png'];
    }
    if (this.state === 'block') {
      const newImg = imgCache[b + 'block_' + Math.min(this.frame, 3) + '.png'];
      return newImg || imgCache[b + 'block.png'];
    }
    if (this.state === 'death') {
      const newImg = imgCache[b + 'death_' + Math.min(this.frame, 3) + '.png'];
      return newImg || imgCache[b + 'death.png'];
    }
    if (this.state === 'victory') {
      const newImg = imgCache[b + 'victory_' + (this.frame % 4) + '.png'];
      return newImg || imgCache[b + 'victory.png'];
    }
    return imgCache[b + 'idle_0.png'] || imgCache[b + 'idle.png'];
  }

  draw() {
    const img = this.getImg();
    if (!img) return;

    const scale = CHAR_SCALE;
    const drawW = ~~(img.width * scale);
    const drawH = ~~(img.height * scale);
    const drawY = ~~(this.y - (this.airborne ? this.vy * 3 : 0));

    // Ground shadow: dark solid fillRect, no alpha
    const shadowW = ~~(drawW * 0.3);
    const shadowH = 2;
    X.fillStyle = PAL.stone1;
    X.fillRect(~~(this.x - shadowW / 2), GROUND_Y + 2, shadowW, shadowH);

    X.save();
    X.translate(~~this.x, ~~drawY);
    if (this.facing < 0) X.scale(-1, 1);

    X.drawImage(img, ~~(-drawW / 2), ~~(-drawH + 5), drawW, drawH);
    X.restore();

    // Hit flash: 2-frame bright overlay
    if (this.hitFlash > 0) {
      X.fillStyle = PAL.cream;
      X.fillRect(~~(this.x - drawW / 2), ~~(drawY - drawH + 5), drawW, drawH);
      this.hitFlash--;
    }

    // Frozen tint: solid blue rect overlay
    if (this.frozen > 0) {
      X.fillStyle = PAL.iceDk;
      X.fillRect(~~(this.x - drawW / 2), ~~(drawY - drawH + 5), drawW, drawH);
    }

    // Block shield: simple 1px rect outline
    if (this.state === 'block' || this.blockstun > 0) {
      X.strokeStyle = PAL.ice;
      X.lineWidth = 1;
      X.strokeRect(~~(this.x - drawW * 0.4), ~~(drawY - drawH * 0.8), ~~(drawW * 0.8), ~~(drawH * 0.7));
    }

    // Poison drip: solid pixels
    if (this.poison > 0 && tick % 4 === 0) {
      particles.push({x:~~(this.x+rng(-12,12)), y:~~(drawY-rng(15,50)), vx:~~rng(-1,1), vy:1, life:20, color:PAL.venom, size:2});
    }
  }

  update() {
    this.frameTick++;
    if (this.cooldown > 0) this.cooldown--;
    if (this.hitstun > 0) { this.hitstun--; if (this.hitstun === 0 && this.state === 'hit') { this.state = 'idle'; this.frame = 0; } }
    if (this.blockstun > 0) { this.blockstun--; if (this.blockstun === 0 && this.state === 'block') { this.state = 'idle'; this.frame = 0; } }
    if (this.frozen > 0) this.frozen--;
    if (this.armor > 0) this.armor--;

    if (this.d.id === 'berserker') this.rage = Math.max(0, ((this.maxHp - this.hp) / this.maxHp) * 100);

    if (this.poison > 0 && tick % 50 === 0) {
      this.hp = Math.max(1, this.hp - 15);
      this.poison--;
      spawnDmg(~~this.x, ~~(this.y - 60), '15', PAL.venom);
    }

    const spd = this.state === 'attack' ? 4 : this.state === 'special' ? 6 : this.state === 'super' ? 7 : this.state === 'fatality' ? 10 : this.state === 'hit' ? 4 : this.state === 'death' ? 8 : 8;
    if (this.frameTick >= spd) {
      this.frameTick = 0;
      if (this.state === 'fatality') {
        if (this.fatalFrame < 3) this.fatalFrame++;
      } else if (this.state === 'death') {
        if (this.frame < 3) this.frame++;
      } else if (this.state === 'victory') {
        this.frame = (this.frame + 1) % 4;
      } else if (this.state !== 'idle' && this.state !== 'block' && this.state !== 'hit') {
        this.frame++;
        if (this.frame >= 3) { this.state = 'idle'; this.frame = 0; }
      } else {
        this.frame = (this.frame + 1) % 4;
      }
    }

    if (this.airborne) {
      this.vy -= GRAVITY;
      if (this.vy <= 0) { this.vy = 0; this.airborne = false; }
    }
    this.x += this.vx;
    this.vx *= 0.88;

    if (this.x < STAGE_LEFT) { this.x = STAGE_LEFT; this.vx = Math.abs(this.vx) * 0.5; }
    if (this.x > STAGE_RIGHT) { this.x = STAGE_RIGHT; this.vx = -Math.abs(this.vx) * 0.5; }
    if (this.enemy && Math.abs(this.x - this.enemy.x) < 30) {
      const push = this.x < this.enemy.x ? -1 : 1;
      this.x += push;
      this.enemy.x -= push;
    }
    if (this.canAct && this.state === 'idle') {
      const center = W / 2;
      const distFromCenter = this.x - center;
      if (Math.abs(distFromCenter) > 120) {
        this.x -= distFromCenter * 0.003;
      }
    }

    this.x = ~~this.x;
    if (this.canAct) this.faceEnemy();
    if (this.hitstun <= 0 && this.comboCount > 0) this.comboCount = 0;
  }

  takeDamage(dmg, canBlock) {
    if (this.dead) return;
    if (canBlock && this.state === 'block') {
      const chip = Math.floor(dmg * 0.1);
      this.hp -= chip;
      this.blockstun = 12;
      spawnDmg(~~this.x, ~~(this.y - 70), 'GUARD ' + chip, PAL.ice);
      this.pow = Math.min(100, this.pow + 2);
      spawnSpark(~~(this.x + this.facing * 15), ~~(this.y - 50), 4, PAL.spark);
      return;
    }
    if (this.armor > 0) {
      this.hp -= Math.floor(dmg * 0.4);
      spawnDmg(~~this.x, ~~(this.y - 75), 'ARMOR', PAL.gold);
      return;
    }
    this.hp = Math.max(0, this.hp - dmg);
    this.state = 'hit';
    this.frame = 0;
    this.frameTick = 0;
    this.hitstun = 14;
    this.hitFlash = 2;
    this.pow = Math.min(100, this.pow + Math.floor(dmg * 0.06));
  }

  knockback(f) { this.vx = -this.facing * f; }
  launch(v) { this.airborne = true; this.vy = v; }
}

// ─── UTILS ───
function rng(a,b){return a+Math.random()*(b-a)}
function rngInt(a,b){return Math.floor(rng(a,b+1))}
function pick(a){return a[Math.floor(Math.random()*a.length)]}
function spawnDmg(x,y,t,c){dmgTexts.push({x:~~x,y:~~y,text:t,color:c,life:40,vy:-1})}
function spawnBlood(x,y,n){
  for(let i=0;i<n;i++) particles.push({x:~~x,y:~~(y+rng(-5,5)),vx:~~rng(-4,4),vy:~~rng(-5,-1),life:rngInt(25,50),color:Math.random()>.3?PAL.blood1:Math.random()>.5?PAL.blood2:PAL.black,size:rngInt(2,4),grav:0.4});
}
function spawnSpark(x,y,n,c){
  for(let i=0;i<n;i++) particles.push({x:~~x,y:~~y,vx:~~rng(-3,3),vy:~~rng(-3,-1),life:rngInt(8,18),color:Math.random()>.5?(c||PAL.spark):PAL.sparkHi,size:rngInt(1,2),grav:0.2});
}
function addSlash(x, y, big) {
  slashFX.push({x:~~x, y:~~y, life: big ? 8 : 5, size: big ? 20 : 12});
}
function shake(d){shakeDur=d}
function announce(t,dur,sz){announceText=t;announceTimer=dur||90;announceSize=sz||24}
function addBloodStain(x){bloodStains.push({x:~~x,y:GROUND_Y+2,w:rngInt(3,8)});if(bloodStains.length>30)bloodStains.shift()}

// ─── STAGE BACKGROUND (pure pixel, no gradient/alpha/blur) ───
function drawStage() {
  // Solid background
  X.fillStyle = PAL.bg1;
  X.fillRect(0, 0, W, H);

  // Back wall
  X.fillStyle = PAL.bg2;
  X.fillRect(0, 0, W, GROUND_Y - 15);

  // Stone pillars
  const pillars = [30, 100, W - 100, W - 30];
  for (const px of pillars) {
    X.fillStyle = PAL.stone1;
    X.fillRect(px - 8, 10, 16, GROUND_Y - 22);
    X.fillStyle = PAL.stone2;
    X.fillRect(px - 6, 10, 12, GROUND_Y - 22);
    // Pillar cap
    X.fillStyle = PAL.stone3;
    X.fillRect(px - 10, 7, 20, 6);
    X.fillRect(px - 10, GROUND_Y - 15, 20, 4);

    // Torch: solid pixel flame (no arc, no alpha)
    const flick = (tick + px) % 8 < 4 ? 0 : 1;
    X.fillStyle = PAL.fire1;
    X.fillRect(px - 2, 18 + flick, 4, 6);
    X.fillStyle = PAL.fireHi;
    X.fillRect(px - 1, 19 + flick, 2, 3);
    X.fillStyle = PAL.fire2;
    X.fillRect(px - 1, 24 + flick, 2, 2);

    // Torch light: dithering pattern (1px dots)
    X.fillStyle = PAL.fire1;
    for (let dy = -8; dy < 8; dy += 2) {
      for (let dx = -8; dx < 8; dx += 2) {
        if ((dx + dy + tick) % 4 === 0) {
          X.fillRect(px + dx, 22 + dy, 1, 1);
        }
      }
    }
  }

  // Red banners
  for (const bx of [65, W - 65]) {
    X.fillStyle = PAL.blood2;
    X.fillRect(bx - 5, 14, 10, 60);
    X.fillStyle = PAL.blood1;
    X.fillRect(bx - 4, 16, 8, 56);
    // Banner symbol (small cross pattern)
    X.fillStyle = PAL.gold;
    X.fillRect(bx - 1, 36, 2, 8);
    X.fillRect(bx - 3, 39, 6, 2);
  }

  // Center throne silhouette
  X.fillStyle = PAL.stone1;
  X.fillRect(W / 2 - 20, 20, 40, 70);
  X.fillStyle = PAL.stone2;
  X.fillRect(W / 2 - 16, 25, 32, 60);

  // Floor: 2-color checkerboard (no perspective, side view)
  const tileW = 12, tileH = 8;
  for (let gy = GROUND_Y - 12; gy < H; gy += tileH) {
    for (let gx = 0; gx < W; gx += tileW) {
      const checker = ((gx / tileW) + (gy / tileH)) % 2;
      X.fillStyle = checker ? PAL.floor1 : PAL.floor2;
      X.fillRect(gx, gy, tileW, tileH);
    }
  }

  // Ground line
  X.fillStyle = PAL.stone3;
  X.fillRect(0, GROUND_Y - 13, W, 1);

  // Blood stains on floor (solid dark rects, no alpha)
  X.fillStyle = '#220404';
  bloodStains.forEach(b => {
    X.fillRect(b.x, b.y, b.w, 1);
  });
}

// ─── HUD (pixel style: 1px borders, solid fills, no alpha/blur) ───
function drawHUD() {
  if (!p1 || !p2) return;
  const barW = 148, barH = 8, barY = 10, barGap = 16;

  // Dark HUD background bar (solid, no rgba)
  X.fillStyle = PAL.black;
  X.fillRect(0, 0, W, 28);

  // P1 HP bar (right-to-left fill)
  const p1x = W / 2 - barGap;
  drawHP(p1x - barW, barY, barW, barH, p1.hp, p1.maxHp, true);

  // P2 HP bar (left-to-right fill)
  const p2x = W / 2 + barGap;
  drawHP(p2x, barY, barW, barH, p2.hp, p2.maxHp, false);

  // Names
  X.font = '8px NeoDGM, monospace';
  X.textAlign = 'left';
  X.fillStyle = PAL.white;
  X.fillText(p1.d.name, 4, barY - 1);
  X.textAlign = 'right';
  X.fillText(p2.d.name, W - 4, barY - 1);

  // Timer (big, centered)
  X.textAlign = 'center';
  X.font = '14px NeoDGM, monospace';
  X.fillStyle = gameTimer > 20 ? PAL.cream : PAL.hpR;
  // 1px drop shadow
  X.fillStyle = PAL.black;
  X.fillText(String(gameTimer).padStart(2, '0'), W / 2 + 1, barY + 8);
  X.fillStyle = gameTimer > 20 ? PAL.cream : PAL.hpR;
  X.fillText(String(gameTimer).padStart(2, '0'), W / 2, barY + 7);

  // Round indicator
  X.font = '6px NeoDGM, monospace';
  X.fillStyle = PAL.stone3;
  X.fillText('R' + roundNum, W / 2, barY + 15);

  // Win dots (solid rects)
  for (let i = 0; i < p1Wins; i++) { X.fillStyle = PAL.hpR; X.fillRect(6 + i * 6, barY + barH + 4, 4, 4); }
  for (let i = 0; i < p2Wins; i++) { X.fillStyle = PAL.hpR; X.fillRect(W - 10 - i * 6, barY + barH + 4, 4, 4); }

  // POW gauges at bottom (2-color bar)
  const powY = H - 12, powW = 80, powH = 4;
  // P1
  X.fillStyle = PAL.stone1;
  X.fillRect(4, powY, powW, powH);
  X.fillStyle = p1.pow >= 100 ? PAL.hpR : PAL.ice;
  X.fillRect(4, powY, ~~(powW * (p1.pow / 100)), powH);
  X.strokeStyle = PAL.stone3; X.lineWidth = 1;
  X.strokeRect(4, powY, powW, powH);
  X.font = '6px NeoDGM, monospace';
  X.fillStyle = p1.pow >= 100 ? PAL.hpR : PAL.ice;
  X.textAlign = 'left';
  X.fillText('POW', 4, powY - 2);
  if (p1.pow >= 100) { X.fillStyle = PAL.hpR; X.fillText('MAX!', 28, powY - 2); }

  // P2
  X.fillStyle = PAL.stone1;
  X.fillRect(W - 4 - powW, powY, powW, powH);
  X.fillStyle = p2.pow >= 100 ? PAL.hpR : PAL.ice;
  X.fillRect(W - 4 - powW, powY, ~~(powW * (p2.pow / 100)), powH);
  X.strokeStyle = PAL.stone3;
  X.strokeRect(W - 4 - powW, powY, powW, powH);
  X.textAlign = 'right';
  X.fillStyle = p2.pow >= 100 ? PAL.hpR : PAL.ice;
  X.fillText('POW', W - 4, powY - 2);
  if (p2.pow >= 100) { X.fillStyle = PAL.hpR; X.fillText('MAX!', W - 28, powY - 2); }

  // Combo display
  if (p1.comboCount >= 2) { X.font = '10px NeoDGM, monospace'; X.fillStyle = PAL.fire1; X.textAlign = 'left'; X.fillText(p1.comboCount + ' HITS!', 6, H / 2); }
  if (p2.comboCount >= 2) { X.font = '10px NeoDGM, monospace'; X.fillStyle = PAL.fire1; X.textAlign = 'right'; X.fillText(p2.comboCount + ' HITS!', W - 6, H / 2); }
}

function drawHP(x, y, w, h, hp, max, rtl) {
  // Background
  X.fillStyle = PAL.stone1;
  X.fillRect(x, y, w, h);
  const pct = Math.max(0, hp / max);
  const fw = ~~(w * pct);
  const c = pct > 0.5 ? PAL.hpG : pct > 0.25 ? PAL.hpY : PAL.hpR;

  if (rtl) {
    X.fillStyle = c;
    X.fillRect(x + w - fw, y, fw, h);
  } else {
    X.fillStyle = c;
    X.fillRect(x, y, fw, h);
  }

  // 1px border
  X.strokeStyle = PAL.stone3;
  X.lineWidth = 1;
  X.strokeRect(x, y, w, h);

  // Segment ticks
  X.fillStyle = PAL.stone2;
  for (let i = 1; i < 10; i++) {
    const tx = ~~(x + (w / 10) * i);
    X.fillRect(tx, y, 1, h);
  }
}

// ─── EFFECTS (pixel style: no alpha, no blur) ───
function drawParticles() {
  particles.forEach(p => {
    p.x = ~~(p.x + p.vx); p.y = ~~(p.y + p.vy); if (p.grav) p.vy += p.grav; p.life--;
    if (p.life > 0) {
      // Color changes by life (bright → dark), no alpha
      let c = p.color;
      if (p.life < 8) c = PAL.stone2; // fade to dark
      else if (p.life < 15) c = p.color; // mid
      X.fillStyle = c;
      X.fillRect(p.x, p.y, p.size, p.size);
    }
  });
  particles = particles.filter(p => p.life > 0);
}

function drawDmgTexts() {
  dmgTexts.forEach(d => {
    d.y = ~~(d.y + d.vy); d.life--;
    if (d.life > 0) {
      X.font = '8px NeoDGM, monospace';
      X.textAlign = 'center';
      // 1px drop shadow
      X.fillStyle = PAL.black;
      X.fillText(d.text, d.x + 1, d.y + 1);
      X.fillStyle = d.life < 10 ? PAL.stone3 : d.color;
      X.fillText(d.text, d.x, d.y);
    }
  });
  dmgTexts = dmgTexts.filter(d => d.life > 0);
}

function drawSlashFX() {
  slashFX.forEach(s => {
    s.life--;
    if (s.life > 0) {
      // Slash = 3~4 fillRect chunks forming an arc
      const sz = s.size;
      const c = s.life > 4 ? PAL.sparkHi : PAL.spark;
      X.fillStyle = c;
      X.fillRect(s.x - sz, s.y - 1, sz, 2);
      X.fillRect(s.x, s.y - 2, sz, 2);
      X.fillRect(s.x - ~~(sz * 0.5), s.y + 1, sz, 1);
      if (sz > 15) {
        X.fillRect(s.x + ~~(sz * 0.3), s.y - 3, ~~(sz * 0.5), 1);
      }
    }
  });
  slashFX = slashFX.filter(s => s.life > 0);
}

function drawAnnounce() {
  if (announceTimer <= 0) return;
  announceTimer--;
  X.font = announceSize + 'px NeoDGM, monospace';
  X.textAlign = 'center';
  // 1px drop shadow (no blur, no strokeText with thick line)
  X.fillStyle = PAL.black;
  X.fillText(announceText, W / 2 + 1, ~~(H / 2 - 12) + 1);
  X.fillStyle = announceSize > 20 ? PAL.hpR : PAL.gold;
  X.fillText(announceText, W / 2, ~~(H / 2 - 12));
}

function drawFlash() {
  if (flashFrames > 0) {
    X.fillStyle = flashColor;
    X.fillRect(0, 0, W, H);
    flashFrames--;
  }
}

// ─── AI ───
function aiBrain(me, foe) {
  if (!me.canAct) return null;
  const d = me.dist;
  const r = Math.random();
  const style = me.d.style;

  const inRange = d <= ATTACK_RANGE;
  const midRange = d > ATTACK_RANGE && d <= 150;
  const farRange = d > 150;

  if (inRange && foe.hitstun > 4) {
    return r < 0.8 ? 'attack' : (me.pow >= 30 ? 'special' : 'attack');
  }

  if (inRange && me.pow >= 100 && r < 0.5) return 'super';
  if (inRange && me.pow >= 30 && r < 0.2) return 'special';

  if (farRange) return r < 0.5 ? 'dash' : 'walk';
  if (midRange) {
    if (style === 'rush') return r < 0.6 ? 'dash' : 'walk';
    if (style === 'grapple') return r < 0.7 ? 'walk' : 'block';
    if (style === 'zone') return r < 0.4 ? 'walk' : r < 0.7 ? 'block' : 'walk';
    return r < 0.5 ? 'dash' : 'walk';
  }

  switch(style) {
    case 'rush':    return r < 0.55 ? 'attack' : r < 0.75 ? 'special' : 'attack';
    case 'grapple': return r < 0.5 ? 'attack' : r < 0.7 ? 'block' : 'special';
    case 'mixup':   return pick(['attack','attack','special','back','attack']);
    case 'zone':    return r < 0.4 ? 'attack' : r < 0.6 ? 'special' : 'back';
  }
  return r < 0.6 ? 'attack' : 'block';
}

function execAction(me, foe, act) {
  if (!act || !me.canAct) return;
  me.faceEnemy();
  me.lastAction = act;

  switch(act) {
    case 'walk':
      me.vx = me.facing * 2;
      me.state = 'walk'; me.frame = 0;
      me.cooldown = 5;
      break;
    case 'back':
      me.vx = -me.facing * 3;
      me.cooldown = 10;
      break;
    case 'dash':
      me.vx = me.facing * 5;
      me.state = 'dash'; me.frame = 0;
      me.cooldown = 16;
      break;
    case 'block':
      me.state = 'block'; me.cooldown = 18;
      setTimeout(() => { if (me.state === 'block') { me.state = 'idle'; me.frame = 0; } }, 600);
      break;
    case 'attack': doAttack(me, foe); break;
    case 'special': doSpecial(me, foe); break;
    case 'super': doSuper(me, foe); break;
  }
}

function doAttack(me, foe) {
  me.state = 'attack'; me.frame = 0; me.frameTick = 0;
  me.cooldown = Math.max(10, 28 - me.d.spd);
  setTimeout(() => {
    if (!foe.alive || me.dead) return;
    if (me.dist > ATTACK_RANGE + 10) return;
    if (Math.random() < foe.d.spd * 0.004) { spawnDmg(~~foe.x, ~~(foe.y - 60), 'DODGE', PAL.ice); return; }

    let dmg = me.d.atk * 3 + rngInt(-5, 10);
    if (me.rage > 40) dmg += Math.floor(me.rage * 0.3);
    const crit = Math.random() < 0.1;
    if (crit) dmg = Math.floor(dmg * 2);
    if (foe.hitstun > 0) { me.comboCount++; dmg = Math.floor(dmg * Math.max(0.4, 1 - me.comboCount * 0.1)); }
    dmg = Math.max(5, Math.floor(dmg - foe.d.def * 0.8));

    foe.takeDamage(dmg, true);
    foe.knockback(3 + (crit ? 2 : 0));
    me.pow = Math.min(100, me.pow + 4);

    const hx = ~~((me.x + foe.x) / 2);
    const hy = ~~(GROUND_Y - 50);
    addSlash(hx, hy, crit);
    spawnDmg(~~foe.x, ~~(foe.y - 70), (crit ? '!' : '') + dmg, crit ? PAL.fire1 : PAL.hpR);
    spawnBlood(hx, hy, crit ? 12 : 5);
    spawnSpark(hx, hy, 4, PAL.spark);
    addBloodStain(foe.x);
    shake(crit ? 6 : 3);
  }, 120);
}

function doSpecial(me, foe) {
  if (me.pow < 30) { doAttack(me, foe); return; }
  me.pow -= 30;
  me.state = 'special'; me.frame = 0; me.frameTick = 0;
  me.cooldown = 32;
  flashFrames = 2; flashColor = me.d.color;
  spawnDmg(~~me.x, ~~(me.y - 80), me.d.special, me.d.color);

  setTimeout(() => {
    if (!foe.alive || me.dead) return;
    if (me.dist > 100) return;
    let dmg = Math.floor(me.d.atk * 4.5) + rngInt(0, 15);
    dmg = Math.max(10, Math.floor(dmg - foe.d.def * 0.5));

    if (me.d.id === 'venomqueen') { foe.poison += 4; spawnDmg(~~foe.x, ~~(foe.y-65), 'POISON', PAL.venom); }
    if (me.d.id === 'frostbite') { foe.frozen = 40; spawnDmg(~~foe.x, ~~(foe.y-65), 'FREEZE', PAL.ice); }
    if (me.d.id === 'ironclaw' || me.d.id === 'bonecrusher') me.armor = 25;
    if (me.d.id === 'shadowblade') dmg = Math.floor(dmg * 1.4);
    if (me.d.id === 'hellfire') {
      for (let i = 0; i < 15; i++) particles.push({x:~~(foe.x+rng(-20,20)),y:~~(GROUND_Y-rng(25,75)),vx:~~rng(-2,2),vy:~~rng(-2,-1),life:25,color:pick([PAL.fire1,PAL.fire2,PAL.fireHi]),size:rngInt(2,4),grav:-0.1});
    }
    if (me.d.id === 'berserker') dmg += Math.floor(me.rage * 0.4);

    foe.takeDamage(dmg, true);
    foe.knockback(4);
    foe.launch(5);
    const hx = ~~((me.x + foe.x) / 2);
    addSlash(hx, ~~(GROUND_Y - 50), true);
    spawnBlood(~~foe.x, ~~(GROUND_Y - 50), 12);
    shake(8);
    slowmo = 10;
  }, 180);
}

function doSuper(me, foe) {
  if (me.pow < 100) { doSpecial(me, foe); return; }
  me.pow = 0;
  me.state = 'super'; me.frame = 0; me.frameTick = 0;
  me.cooldown = 50;
  me.armor = 35;
  flashFrames = 3; flashColor = PAL.white;
  slowmo = 25;
  announce(me.d.super + '!!', 70, 16);

  setTimeout(() => {
    if (!foe.alive || me.dead) return;
    if (me.dist > 120) return;
    let dmg = Math.floor(me.d.atk * 7) + rngInt(5, 25);
    dmg = Math.max(20, Math.floor(dmg - foe.d.def * 0.3));
    foe.takeDamage(dmg, false);
    foe.knockback(6);
    foe.launch(8);

    const hx = ~~((me.x + foe.x) / 2);
    addSlash(hx, ~~(GROUND_Y - 60), true);
    addSlash(hx + 15, ~~(GROUND_Y - 40), true);
    spawnBlood(~~foe.x, ~~(GROUND_Y - 50), 25);
    for (let i = 0; i < 20; i++) particles.push({x:~~rng(50,W-50),y:~~rng(50,170),vx:~~rng(-1,1),vy:~~rng(-2,1),life:30,color:me.d.color,size:rngInt(2,4),grav:0.1});
    spawnDmg(~~foe.x, ~~(foe.y - 80), '' + dmg, PAL.gold);
    shake(14);
  }, 300);
}

// ─── FATALITY ───
function triggerFatality(winner, loser) {
  scene = 'fatality';
  const ft = pick(FATALITIES);
  loser.state = 'fatality'; loser.fatalType = ft; loser.fatalFrame = 0; loser.dead = true;
  flashFrames = 3; flashColor = PAL.blood1;
  slowmo = 35; shake(20);
  spawnBlood(~~loser.x, ~~(GROUND_Y - 50), 50);
  announce('FATALITY - ' + FATALITY_KR[ft], 120, 18);
  setTimeout(() => { winner.state = 'victory'; winner.frame = 0; }, 1500);
  setTimeout(() => {
    if (winner === p1) p1Wins++; else p2Wins++;
    goNextRound();
  }, 4000);
}

function goNextRound() {
  if (p1Wins >= 2 || p2Wins >= 2) { scene = 'result'; return; }
  roundNum++;
  [p1, p2].forEach((f, i) => {
    f.hp = f.maxHp; f.pow = 0; f.dead = false; f.state = 'idle'; f.frame = 0;
    f.x = i === 0 ? 90 : W - 90;
    f.vy = 0; f.vx = 0; f.airborne = false; f.poison = 0; f.frozen = 0; f.comboCount = 0;
  });
  bloodStains = []; particles = []; dmgTexts = []; slashFX = [];
  introTimer = 0; gameTimer = 99; timerTick = 0;
  scene = 'intro';
}

// ─── SCENES ───
function drawTitle() {
  drawStage();
  // Dark overlay (solid, no rgba)
  X.fillStyle = PAL.black;
  X.fillRect(0, 0, W, H);
  // Partial redraw for visibility
  X.fillStyle = PAL.bg2;
  X.fillRect(0, 0, W, H);

  X.textAlign = 'center';
  // Title with 1px drop shadow
  X.font = '20px NeoDGM, monospace';
  X.fillStyle = PAL.black;
  X.fillText('AI COLOSSEUM', W / 2 + 1, 61);
  X.fillStyle = PAL.hpR;
  X.fillText('AI COLOSSEUM', W / 2, 60);

  X.font = '8px NeoDGM, monospace';
  X.fillStyle = PAL.cream;
  X.fillText('PIXEL DEATH ARENA', W / 2, 74);

  X.font = '6px NeoDGM, monospace';
  X.fillStyle = PAL.gold;
  X.fillText('AI vs AI AUTO COMBAT - 3R 2WIN - GORE', W / 2, 86);

  // Showcase fighter
  const idx = Math.floor(tick / 80) % FIGHTERS.length;
  const sf = FIGHTERS[idx];
  const img = imgCache[ASSET + sf.id + '/idle.png'];
  if (img) { X.drawImage(img, W / 2 - 32, 100, 64, 64); }
  X.font = '7px NeoDGM, monospace'; X.fillStyle = sf.color;
  X.fillText(sf.name + ' - ' + sf.weapon, W / 2, 175);

  if (~~(tick / 25) % 2 === 0) { X.font = '8px NeoDGM, monospace'; X.fillStyle = PAL.cream; X.fillText('[ CLICK TO START ]', W / 2, 195); }
}

function drawSelect() {
  drawStage();
  X.fillStyle = PAL.black; X.fillRect(0, 0, W, H);
  X.fillStyle = PAL.bg2; X.fillRect(0, 0, W, H);

  X.textAlign = 'center';
  X.font = '10px NeoDGM, monospace'; X.fillStyle = PAL.gold; X.fillText('FIGHTER SELECT', W / 2, 14);

  const cols = 4, cw = 90, ch = 80, sx = ~~((W - cols * cw) / 2), sy = 20;
  FIGHTERS.forEach((f, i) => {
    const c = i % cols, r = Math.floor(i / cols);
    const cx = sx + c * cw + ~~(cw / 2), cy = sy + r * ch + ~~(ch / 2);
    const isP1 = i === selectP1, isP2 = i === selectP2;

    if (isP1 || isP2) {
      X.strokeStyle = isP1 ? PAL.hpR : PAL.ice;
      X.lineWidth = 1;
      X.strokeRect(cx - ~~(cw / 2) + 4, cy - ~~(ch / 2) + 2, cw - 8, ch - 4);
      X.font = '6px NeoDGM, monospace'; X.fillStyle = isP1 ? PAL.hpR : PAL.ice;
      X.fillText(isP1 ? '1P' : '2P', cx, cy - ~~(ch / 2) + 10);
    }
    const img = imgCache[ASSET + f.id + '/idle.png'];
    if (img) X.drawImage(img, cx - 20, cy - 22, 40, 40);
    X.font = '6px NeoDGM, monospace'; X.fillStyle = f.color; X.fillText(f.name, cx, cy + 26);
    X.font = '5px NeoDGM, monospace'; X.fillStyle = PAL.stone3; X.fillText(f.weapon + ' A:' + f.atk + ' S:' + f.spd, cx, cy + 34);
  });

  selectTimer++;
  if (selectTimer > 100) startMatch();
  X.font = '7px NeoDGM, monospace'; X.fillStyle = PAL.cream;
  X.fillText(FIGHTERS[selectP1].name + '  vs  ' + FIGHTERS[selectP2].name, W / 2, H - 10);
  X.font = '5px NeoDGM, monospace'; X.fillStyle = PAL.stone3; X.fillText('AUTO SELECT...', W / 2, H - 3);
}

let introTimer = 0;
function drawIntro() {
  drawStage();
  if (p1) p1.draw(); if (p2) p2.draw();
  drawHUD();
  introTimer++;
  X.textAlign = 'center';
  if (introTimer < 50) {
    X.font = '18px NeoDGM, monospace';
    // 1px drop shadow
    X.fillStyle = PAL.black;
    X.fillText('ROUND ' + roundNum, W / 2 + 1, ~~(H / 2 - 12) + 1);
    X.fillStyle = PAL.gold;
    X.fillText('ROUND ' + roundNum, W / 2, ~~(H / 2 - 12));
  } else if (introTimer < 85) {
    X.font = '24px NeoDGM, monospace';
    X.fillStyle = PAL.black;
    X.fillText('FIGHT!', W / 2 + 1, ~~(H / 2 - 8) + 1);
    X.fillStyle = PAL.hpR;
    X.fillText('FIGHT!', W / 2, ~~(H / 2 - 8));
  } else { scene = 'fighting'; tick = 0; timerTick = 0; }
}

function drawResult() {
  drawStage();
  if (p1) p1.draw(); if (p2) p2.draw();
  drawParticles();
  X.fillStyle = PAL.black; X.fillRect(0, 0, W, H);
  X.fillStyle = PAL.bg2; X.fillRect(0, 0, W, H);

  X.textAlign = 'center';
  const w = p1Wins >= 2 ? p1 : p2;
  X.font = '16px NeoDGM, monospace';
  X.fillStyle = PAL.black;
  X.fillText(w.d.name + ' WINS!', W / 2 + 1, 56);
  X.fillStyle = PAL.gold;
  X.fillText(w.d.name + ' WINS!', W / 2, 55);

  X.font = '8px NeoDGM, monospace'; X.fillStyle = PAL.cream;
  X.fillText(w.d.weapon + ' | ' + p1Wins + ' - ' + p2Wins, W / 2, 70);

  const img = imgCache[ASSET + w.d.id + '/idle.png'];
  if (img) X.drawImage(img, W / 2 - 32, 80, 64, 64);

  if (~~(tick / 25) % 2 === 0) { X.font = '8px NeoDGM, monospace'; X.fillStyle = PAL.cream; X.fillText('[ CLICK TO RESTART ]', W / 2, 170); }
}

// ─── MAIN LOOP ───
function loop() {
  tick++;
  if (slowmo > 0) { slowmo--; if (tick % 3 !== 0) { requestAnimationFrame(loop); return; } }

  X.clearRect(0, 0, W, H);
  X.imageSmoothingEnabled = false;

  if (shakeDur > 0) { shakeX = ~~((Math.random() - .5) * shakeDur * 0.4); shakeY = ~~((Math.random() - .5) * shakeDur * 0.4); shakeDur--; } else { shakeX = 0; shakeY = 0; }
  X.save(); X.translate(shakeX, shakeY);

  switch(scene) {
    case 'title': drawTitle(); break;
    case 'select': drawSelect(); break;
    case 'loading':
      X.fillStyle = PAL.black; X.fillRect(0, 0, W, H);
      X.textAlign = 'center'; X.font = '8px NeoDGM, monospace'; X.fillStyle = PAL.cream;
      X.fillText('LOADING... ' + loaded + '/' + totalLoad, W / 2, H / 2);
      X.fillStyle = PAL.stone1; X.fillRect(W / 2 - 60, ~~(H / 2) + 6, 120, 6);
      X.fillStyle = PAL.gold; X.fillRect(W / 2 - 60, ~~(H / 2) + 6, ~~(120 * (loaded / Math.max(1, totalLoad))), 6);
      break;
    case 'intro': drawIntro(); break;
    case 'fighting':
      drawStage();
      timerTick++;
      if (timerTick >= 60) { timerTick = 0; gameTimer = Math.max(0, gameTimer - 1); }
      if (tick % Math.max(8, 22 - p1.d.spd) === 0) execAction(p1, p2, aiBrain(p1, p2));
      if (tick % Math.max(8, 22 - p2.d.spd) === 0) execAction(p2, p1, aiBrain(p2, p1));
      p1.update(); p2.update();
      [p1, p2].sort((a, b) => a.y - b.y).forEach(f => f.draw());
      drawSlashFX(); drawParticles(); drawDmgTexts(); drawHUD(); drawAnnounce();
      // KO check
      if (p1.hp <= 0 && !p1.dead) {
        p1.hp = 0;
        if (p2.hp === p2.maxHp) announce('PERFECT!', 80, 20);
        if (Math.random() < 0.35) triggerFatality(p2, p1);
        else { p1.state = 'death'; p1.frame = 0; p1.dead = true; p2.state = 'victory'; p2.frame = 0; announce('K.O.!', 80, 24); shake(10); flashFrames = 2; flashColor = PAL.white; setTimeout(() => { p2Wins++; goNextRound(); }, 3000); }
      }
      if (p2.hp <= 0 && !p2.dead) {
        p2.hp = 0;
        if (p1.hp === p1.maxHp) announce('PERFECT!', 80, 20);
        if (Math.random() < 0.35) triggerFatality(p1, p2);
        else { p2.state = 'death'; p2.frame = 0; p2.dead = true; p1.state = 'victory'; p1.frame = 0; announce('K.O.!', 80, 24); shake(10); flashFrames = 2; flashColor = PAL.white; setTimeout(() => { p1Wins++; goNextRound(); }, 3000); }
      }
      if (gameTimer <= 0 && !p1.dead && !p2.dead) {
        announce('TIME UP!', 80, 20);
        const pp1 = p1.hp / p1.maxHp, pp2 = p2.hp / p2.maxHp;
        if (pp1 > pp2) { p2.dead = true; p1Wins++; } else if (pp2 > pp1) { p1.dead = true; p2Wins++; } else { p1Wins++; p2Wins++; }
        setTimeout(() => goNextRound(), 2000);
      }
      break;
    case 'fatality':
      drawStage();
      p1.update(); p2.update();
      [p1, p2].sort((a, b) => a.y - b.y).forEach(f => f.draw());
      drawSlashFX(); drawParticles(); drawDmgTexts(); drawHUD(); drawAnnounce();
      break;
    case 'result': drawResult(); break;
  }
  drawFlash();
  X.restore();
  requestAnimationFrame(loop);
}

async function startMatch() {
  scene = 'loading';
  f1Data = FIGHTERS[selectP1]; f2Data = FIGHTERS[selectP2];
  await Promise.all([preloadFighter(f1Data), preloadFighter(f2Data)]);
  p1 = new Fighter(f1Data, 'left'); p2 = new Fighter(f2Data, 'right');
  p1.enemy = p2; p2.enemy = p1;
  p1Wins = 0; p2Wins = 0; roundNum = 1; gameTimer = 99; timerTick = 0;
  bloodStains = []; particles = []; dmgTexts = []; slashFX = [];
  introTimer = 0; scene = 'intro';
}

C.addEventListener('click', () => {
  if (scene === 'title' || scene === 'result') {
    const idx = [...Array(8).keys()].sort(() => Math.random() - .5);
    selectP1 = idx[0]; selectP2 = idx[1]; selectTimer = 0; scene = 'select';
  }
});

Promise.all(FIGHTERS.map(f => loadImg(ASSET + f.id + '/idle.png')));
loop();
</script>
</body>
</html>
