<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>‚öîÔ∏è AI ÏΩúÎ°úÏÑ∏ÏõÄ ‚Äî PIXEL DEATH ARENA</title>
<style>
@font-face{font-family:'NeoDGM';src:url('/static/fonts/neodgm.woff2') format('woff2');font-display:swap}
*{margin:0;padding:0;box-sizing:border-box}
body{background:#050F1A;color:#FCC88E;font-family:'NeoDGM',monospace;overflow:hidden;height:100vh}
canvas{display:block;margin:0 auto;image-rendering:pixelated;image-rendering:crisp-edges}
a{color:#69B5A8;text-decoration:none}
</style>
</head>
<body>
<canvas id="G"></canvas>
<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// AI ÏΩúÎ°úÏÑ∏ÏõÄ ‚Äî KOF-STYLE PIXEL FIGHTING GAME
// Spectator-only: AI vs AI, auto-combat
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const C = document.getElementById('G');
const X = C.getContext('2d');
const W = 800, H = 500;
C.width = W; C.height = H;

// Scale canvas to fit screen
function resize() {
  const s = Math.min(innerWidth / W, innerHeight / H);
  C.style.width = (W * s) + 'px';
  C.style.height = (H * s) + 'px';
}
resize();
addEventListener('resize', resize);

// ‚îÄ‚îÄ‚îÄ PALETTE ‚îÄ‚îÄ‚îÄ
const COL = {
  bg: '#050F1A', dark: '#221C20', teal: '#073935', brown: '#4D2C2C',
  wood: '#704637', green: '#126D65', tan: '#8F604C', red: '#D24C59',
  gold: '#9D7F33', copper: '#C17F54', grey: '#938B7B', mint: '#35B97D',
  sea: '#69B5A8', orange: '#F09858', cream: '#FCC88E', light: '#A2E3CA'
};

// ‚îÄ‚îÄ‚îÄ FIGHTERS ‚îÄ‚îÄ‚îÄ
const FIGHTERS = [
  {id:'bloodfang',   name:'Î∏îÎü¨ÎìúÌå°',      weapon:'ÎèÑÎÅº',   color:COL.red,    style:'rush',    atk:18, def:8,  spd:13, hp:105, special:'ÏßÄÏò•Ï∞∏Í≤©', super:'Î∏îÎü¨ÎìúÎ†àÏù∏'},
  {id:'ironclaw',    name:'ÏïÑÏù¥Ïñ∏ÌÅ¥Î°ú',    weapon:'Ï≤†Ìá¥',   color:COL.grey,   style:'grapple', atk:14, def:16, spd:7,  hp:140, special:'ÏïÑÏù¥Ïñ∏Ïõî', super:'ÌÅ¨Îü¨ÏÖîÏûÑÌå©Ìä∏'},
  {id:'shadowblade', name:'ÏâêÎèÑÏö∞Î∏îÎ†àÏù¥Îìú',weapon:'ÏåçÎã®Í≤Ä', color:COL.teal,   style:'mixup',   atk:20, def:5,  spd:18, hp:88,  special:'ÌôòÏòÅÏ∞∏',   super:'Î¨¥ÏòÅÎÇúÎ¨¥'},
  {id:'berserker',   name:'Î≤ÑÏÑúÏª§',        weapon:'Ïπ¥ÌÉÄÎÇò', color:COL.orange,  style:'rush',    atk:22, def:4,  spd:16, hp:92,  special:'Î∞úÍ¥ëÏ∞∏',   super:'ÏïÑÏàòÎùºÏ∞∏ÏòÅÏßÑ'},
  {id:'bonecrusher', name:'Î≥∏ÌÅ¨Îü¨ÏÖî',      weapon:'Ìï¥Î®∏',   color:COL.wood,   style:'grapple', atk:17, def:14, spd:5,  hp:135, special:'Ïñ¥Ïä§ÌÄòÏù¥ÌÅ¨', super:'Î©îÌÖåÏò§Ìï¥Î®∏'},
  {id:'venomqueen',  name:'Î≤†ÎÜàÌÄ∏',        weapon:'ÎèÖÍ≤Ä',   color:COL.green,  style:'zone',    atk:12, def:10, spd:14, hp:100, special:'ÎèÖÎ¨¥Ìôî',   super:'Îç∞Ïä§Î∏îÎ£∏'},
  {id:'hellfire',    name:'Ìó¨ÌååÏù¥Ïñ¥',      weapon:'ÌôîÏóºÍ≤Ä', color:COL.orange,  style:'mixup',   atk:20, def:7,  spd:12, hp:98,  special:'ÌôîÏóºÏÑ†Ìíç', super:'Ïù∏ÌéòÎ•¥ÎÖ∏'},
  {id:'frostbite',   name:'ÌîÑÎ°úÏä§Ìä∏Î∞îÏù¥Ìä∏',weapon:'ÎπôÍ≤∞Ï∞Ω', color:COL.sea,    style:'zone',    atk:13, def:12, spd:10, hp:115, special:'ÎπôÍ≤∞ÏßÑ',   super:'Ï†àÎåÄÏòÅÎèÑ'},
];

const FATALITIES = ['head_off','bisect','explode','impale','spine_rip','dissolve'];
const FATALITY_KR = {head_off:'Ï∞∏Ïàò',bisect:'ÏñëÎã®',explode:'Ìè≠ÏÇ¨',impale:'Í¥ÄÌÜµ',spine_rip:'Ï≤ôÏ∂îÏ†ÅÏ∂ú',dissolve:'Ïö©Ìï¥'};

const ASSET = '/colosseum/assets/';
const imgCache = {};
let totalLoad = 0, loaded = 0;

function loadImg(p) {
  if (imgCache[p]) return Promise.resolve(imgCache[p]);
  totalLoad++;
  return new Promise((res) => {
    const img = new Image();
    img.onload = () => { imgCache[p] = img; loaded++; res(img); };
    img.onerror = () => { loaded++; res(null); };
    img.src = p;
  });
}

function preloadFighter(f) {
  const b = ASSET + f.id + '/';
  const ps = [loadImg(b+'idle.png'), loadImg(b+'idle_64.png')];
  for (const a of ['walk','attack','hit','death','victory'])
    for (let i = 0; i < 4; i++) ps.push(loadImg(b+a+'_'+i+'.png'));
  for (const ft of FATALITIES)
    for (let i = 0; i < 4; i++) ps.push(loadImg(b+'fatality_'+ft+'_'+i+'.png'));
  return Promise.all(ps);
}

// ‚îÄ‚îÄ‚îÄ GAME STATE ‚îÄ‚îÄ‚îÄ
let scene = 'title'; // title, select, loading, intro, fighting, ko, fatality, result, nextround
let tick = 0, roundNum = 1, p1Wins = 0, p2Wins = 0;
let p1, p2, f1Data, f2Data;
let announceText = '', announceTimer = 0, announceSize = 48;
let slowmo = 0, flashAlpha = 0;
let bloodStains = [];
let particles = [], dmgTexts = [];
let selectP1 = 0, selectP2 = 1, selectTimer = 0;

// ‚îÄ‚îÄ‚îÄ FIGHTER CLASS ‚îÄ‚îÄ‚îÄ
class Fighter {
  constructor(data, side) {
    this.d = data;
    this.side = side;
    this.x = side === 'left' ? 120 : 680;
    this.y = 350;
    this.vx = 0;
    this.hp = data.hp;
    this.maxHp = data.hp;
    this.meter = 0; // super gauge 0~100
    this.state = 'idle'; // idle,walk,dash,attack,hit,block,death,victory,fatality,special,super
    this.frame = 0;
    this.frameTick = 0;
    this.facing = side === 'left' ? 1 : -1;
    this.cooldown = 0;
    this.hitstun = 0;
    this.blockstun = 0;
    this.comboCount = 0;
    this.comboDecay = 1.0;
    this.juggleY = 0; // airborne offset
    this.juggleVY = 0;
    this.airborne = false;
    this.dead = false;
    this.poison = 0;
    this.frozen = 0;
    this.armor = 0; // super armor frames
    this.rage = 0;
    this.fatalType = null;
    this.fatalFrame = 0;
    this.animCallback = null;
    this.animDone = false;
    this.dashTimer = 0;
    this.guardTimer = 0; // auto guard
    this.lastAction = '';
    this.actionHistory = [];
  }

  get alive() { return this.hp > 0 && !this.dead; }
  get canAct() { return this.hitstun <= 0 && this.blockstun <= 0 && this.cooldown <= 0 && this.frozen <= 0 && !this.dead && this.state !== 'fatality'; }
  get inRange() { return Math.abs(this.x - this.enemy.x) < 100; }
  get closeRange() { return Math.abs(this.x - this.enemy.x) < 70; }
  get farRange() { return Math.abs(this.x - this.enemy.x) > 250; }
  get dist() { return Math.abs(this.x - this.enemy.x); }

  setEnemy(e) { this.enemy = e; }

  faceEnemy() {
    if (this.enemy) this.facing = this.x < this.enemy.x ? 1 : -1;
  }

  getImg() {
    const b = ASSET + this.d.id + '/';
    if (this.state === 'fatality') {
      return imgCache[b + 'fatality_' + this.fatalType + '_' + Math.min(this.fatalFrame, 3) + '.png'];
    }
    if (this.state === 'idle' || this.state === 'block') return imgCache[b + 'idle_64.png'];
    if (this.state === 'dash' || this.state === 'walk') {
      return imgCache[b + 'walk_' + (Math.min(this.frame, 3)) + '.png'];
    }
    if (this.state === 'special' || this.state === 'super') {
      return imgCache[b + 'attack_' + Math.min(this.frame, 3) + '.png'];
    }
    const st = ['attack','hit','death','victory'].includes(this.state) ? this.state : 'idle';
    return imgCache[b + st + '_' + Math.min(this.frame, 3) + '.png'];
  }

  draw() {
    const img = this.getImg();
    if (!img) return;
    const sz = 128;
    const drawY = this.y - this.juggleY;

    X.save();
    X.translate(this.x, drawY);
    if (this.facing < 0) X.scale(-1, 1);

    // Flash white on hit
    if (this.state === 'hit' && this.frame < 2) {
      X.globalAlpha = 0.6 + Math.sin(tick * 0.8) * 0.4;
    }
    // Block shield
    if (this.state === 'block') {
      X.globalAlpha = 0.8;
    }
    // Frozen tint
    if (this.frozen > 0) {
      X.filter = 'hue-rotate(180deg) brightness(1.4)';
    }
    // Rage glow
    if (this.rage > 40) {
      X.shadowColor = COL.red;
      X.shadowBlur = this.rage * 0.3;
    }
    // Super armor glow
    if (this.armor > 0) {
      X.shadowColor = COL.gold;
      X.shadowBlur = 15;
    }

    X.drawImage(img, -sz/2, -sz/2, sz, sz);
    X.restore();

    // Shadow
    X.save();
    X.globalAlpha = 0.25;
    X.fillStyle = '#000';
    X.beginPath();
    X.ellipse(this.x, this.y + 50, 28, 7, 0, 0, Math.PI * 2);
    X.fill();
    X.restore();

    // Block effect
    if (this.state === 'block' || this.blockstun > 0) {
      X.save();
      X.globalAlpha = 0.4;
      X.strokeStyle = COL.sea;
      X.lineWidth = 2;
      X.beginPath();
      X.arc(this.x, drawY, 50, 0, Math.PI * 2);
      X.stroke();
      X.restore();
    }

    // Poison particles
    if (this.poison > 0 && tick % 3 === 0) {
      particles.push({ x: this.x + rng(-20,20), y: drawY + rng(-30,10), vx: rng(-1,1), vy: -1.5, life: 15, color: COL.green, size: 3 });
    }
  }

  update() {
    this.frameTick++;
    if (this.cooldown > 0) this.cooldown--;
    if (this.hitstun > 0) this.hitstun--;
    if (this.blockstun > 0) this.blockstun--;
    if (this.frozen > 0) this.frozen--;
    if (this.armor > 0) this.armor--;
    if (this.dashTimer > 0) this.dashTimer--;

    // Berserker rage
    if (this.d.style === 'rush' && this.d.id === 'berserker') {
      this.rage = Math.max(0, ((this.maxHp - this.hp) / this.maxHp) * 100);
    }

    // Poison tick
    if (this.poison > 0 && tick % 40 === 0) {
      this.takeDamage(2, false);
      this.poison--;
      spawnDmg(this.x, this.y - this.juggleY - 70, 'üß™2', COL.green);
    }

    // Animation
    const animSpd = this.state === 'attack' ? 5 : this.state === 'special' ? 7 : this.state === 'super' ? 8 : this.state === 'fatality' ? 12 : this.state === 'hit' ? 5 : 7;
    if (this.frameTick >= animSpd) {
      this.frameTick = 0;
      if (this.state === 'fatality') {
        if (this.fatalFrame < 3) this.fatalFrame++;
      } else if (this.state === 'death') {
        if (this.frame < 3) this.frame++;
      } else if (this.state === 'victory') {
        this.frame = (this.frame + 1) % 4;
      } else if (this.state !== 'idle' && this.state !== 'block') {
        this.frame++;
        if (this.frame >= 4) {
          if (this.animCallback) { this.animCallback(); this.animCallback = null; }
          this.state = 'idle';
          this.frame = 0;
          this.animDone = true;
        }
      } else {
        // idle breathing
        this.frame = (this.frame + 1) % 4;
      }
    }

    // Juggle physics
    if (this.airborne) {
      this.juggleVY -= 0.6;
      this.juggleY += this.juggleVY;
      if (this.juggleY <= 0) {
        this.juggleY = 0;
        this.juggleVY = 0;
        this.airborne = false;
      }
    }

    // Apply velocity
    this.x += this.vx;
    this.vx *= 0.9;

    // Boundaries
    this.x = Math.max(60, Math.min(W - 60, this.x));

    // Face enemy
    if (this.canAct) this.faceEnemy();

    // Combo decay
    if (this.hitstun <= 0 && this.comboCount > 0) {
      this.comboCount = 0;
      this.comboDecay = 1.0;
    }
  }

  takeDamage(dmg, canBlock) {
    if (this.dead) return;
    // Check block
    if (canBlock && this.state === 'block' && this.blockstun <= 0) {
      const reduced = Math.floor(dmg * 0.15);
      this.hp -= reduced;
      this.blockstun = 10;
      spawnDmg(this.x, this.y - this.juggleY - 70, 'üõ°Ô∏è' + reduced, COL.grey);
      this.meter = Math.min(100, this.meter + 3);
      return;
    }
    // Super armor absorb
    if (this.armor > 0) {
      this.hp -= Math.floor(dmg * 0.5);
      spawnDmg(this.x, this.y - this.juggleY - 70, 'ARMOR', COL.gold);
      return;
    }

    this.hp -= dmg;
    this.hp = Math.max(0, this.hp);
    this.state = 'hit';
    this.frame = 0;
    this.frameTick = 0;
    this.hitstun = 12;
    this.meter = Math.min(100, this.meter + Math.floor(dmg * 0.4));

    // Combo tracking on the attacker side is handled in attack
  }

  launch(vy) {
    this.airborne = true;
    this.juggleVY = vy;
  }

  knockback(force) {
    this.vx = -this.facing * force;
  }
}

// ‚îÄ‚îÄ‚îÄ UTILITIES ‚îÄ‚îÄ‚îÄ
function rng(a, b) { return a + Math.random() * (b - a); }
function rngInt(a, b) { return Math.floor(rng(a, b + 1)); }
function pick(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

function spawnDmg(x, y, text, color) {
  dmgTexts.push({ x, y, text, color, life: 35, vy: -2.5 });
}

function spawnBlood(x, y, n) {
  for (let i = 0; i < n; i++) {
    particles.push({
      x, y: y + rng(-15, 15), vx: rng(-6, 6), vy: rng(-8, -1),
      life: rngInt(20, 45), color: Math.random() > 0.3 ? COL.red : COL.brown, size: rng(2, 5), grav: 0.35
    });
  }
}

function spawnSpark(x, y, n, color) {
  for (let i = 0; i < n; i++) {
    particles.push({
      x, y, vx: rng(-4, 4), vy: rng(-5, -1),
      life: rngInt(10, 20), color, size: rng(1, 3), grav: 0.2
    });
  }
}

function addBloodStain(x, y) {
  bloodStains.push({ x, y: y + 48, r: rng(3, 8) });
  if (bloodStains.length > 50) bloodStains.shift();
}

function shake(dur) { shakeDur = dur; }
let shakeDur = 0, shakeX = 0, shakeY = 0;

function announce(text, timer, size) {
  announceText = text;
  announceTimer = timer || 90;
  announceSize = size || 48;
}

// ‚îÄ‚îÄ‚îÄ AI BRAIN ‚îÄ‚îÄ‚îÄ
function aiBrain(me, foe) {
  if (!me.canAct) return null;
  const d = me.dist;
  const style = me.d.style;
  const hpPct = me.hp / me.maxHp;
  const foeHpPct = foe.hp / foe.maxHp;
  const r = Math.random();

  // Super priority: if meter full and in range
  if (me.meter >= 100 && d < 140) {
    if (r < 0.6) return 'super';
  }

  // Special priority
  if (me.meter >= 30 && d < 130) {
    if (r < 0.25) return 'special';
  }

  // Foe in hitstun ‚Üí combo extend
  if (foe.hitstun > 3 && d < 100) {
    if (r < 0.8) return 'attack';
    if (r < 0.9 && me.meter >= 30) return 'special';
  }

  // Style-specific
  if (style === 'rush') {
    // aggressive: dash in, combo, pressure
    if (d > 200) return r < 0.7 ? 'dash' : 'walk';
    if (d > 100) return r < 0.5 ? 'dash' : r < 0.8 ? 'attack' : 'walk';
    if (d < 70) return r < 0.6 ? 'attack' : r < 0.75 ? 'special' : 'back';
    return r < 0.65 ? 'attack' : r < 0.85 ? 'special' : 'block';
  }
  if (style === 'grapple') {
    // walk in, tank hits, command grab
    if (d > 150) return r < 0.6 ? 'walk' : 'block';
    if (d < 80) return r < 0.5 ? 'attack' : r < 0.7 ? 'special' : 'block';
    return r < 0.4 ? 'walk' : r < 0.7 ? 'attack' : 'block';
  }
  if (style === 'mixup') {
    // unpredictable
    if (d > 200) return r < 0.6 ? 'dash' : 'walk';
    if (d < 80) {
      const opts = ['attack','attack','attack','special','back','dash'];
      return pick(opts);
    }
    return r < 0.4 ? 'dash' : r < 0.7 ? 'attack' : 'special';
  }
  if (style === 'zone') {
    // keep distance, poke
    if (d < 80) return r < 0.4 ? 'back' : r < 0.7 ? 'attack' : 'special';
    if (d < 160) return r < 0.5 ? 'special' : r < 0.7 ? 'attack' : 'back';
    return r < 0.3 ? 'walk' : r < 0.6 ? 'special' : 'block';
  }

  // Fallback
  if (d > 180) return 'walk';
  if (d < 100) return r < 0.6 ? 'attack' : 'block';
  return r < 0.5 ? 'walk' : 'attack';
}

function execAction(me, foe, act) {
  if (!act || !me.canAct) return;
  me.lastAction = act;
  me.actionHistory.push(act);
  if (me.actionHistory.length > 10) me.actionHistory.shift();

  me.faceEnemy();

  switch(act) {
    case 'walk':
      me.vx = me.facing * 3;
      me.state = 'walk';
      me.frame = 0;
      me.cooldown = 4;
      break;

    case 'back':
      me.vx = -me.facing * 4;
      me.cooldown = 8;
      break;

    case 'dash':
      me.vx = me.facing * 14;
      me.state = 'dash';
      me.frame = 0;
      me.cooldown = 15;
      me.dashTimer = 10;
      break;

    case 'block':
      me.state = 'block';
      me.cooldown = 15;
      me.guardTimer = 15;
      setTimeout(() => { if (me.state === 'block') { me.state = 'idle'; me.frame = 0; } }, 500);
      break;

    case 'attack':
      doAttack(me, foe);
      break;

    case 'special':
      doSpecial(me, foe);
      break;

    case 'super':
      doSuper(me, foe);
      break;
  }
}

function doAttack(me, foe) {
  me.state = 'attack';
  me.frame = 0;
  me.frameTick = 0;
  me.cooldown = Math.max(8, 22 - me.d.spd);

  setTimeout(() => {
    if (!foe.alive || me.dead) return;
    if (me.dist > 110) { spawnDmg(foe.x, foe.y - 70, 'MISS', COL.grey); return; }

    // Dodge check
    if (Math.random() < foe.d.spd * 0.008) {
      spawnDmg(foe.x, foe.y - 70, 'DODGE', COL.sea);
      return;
    }

    let dmg = me.d.atk + rngInt(-2, 4);
    if (me.rage > 40) dmg += Math.floor(me.rage * 0.12);

    // Crit
    const crit = Math.random() < 0.12;
    if (crit) dmg = Math.floor(dmg * 1.7);

    // Combo scaling
    if (foe.hitstun > 0) {
      me.comboCount++;
      me.comboDecay = Math.max(0.3, 1 - me.comboCount * 0.12);
      dmg = Math.floor(dmg * me.comboDecay);
    }

    dmg = Math.max(1, Math.floor(dmg - foe.d.def * 0.3));
    foe.takeDamage(dmg, true);
    foe.knockback(8 + (crit ? 6 : 0));

    // Meter gain
    me.meter = Math.min(100, me.meter + 5);

    spawnDmg(foe.x, foe.y - foe.juggleY - 70, (crit ? 'üí•' : '') + dmg, crit ? COL.orange : COL.red);
    spawnBlood(foe.x, foe.y - foe.juggleY, crit ? 15 : 6);
    spawnSpark(foe.x + (me.x < foe.x ? -20 : 20), foe.y - foe.juggleY - 20, 5, COL.cream);
    addBloodStain(foe.x, foe.y);
    shake(crit ? 6 : 3);

    if (me.comboCount >= 3) {
      showCombo(me);
    }
    if (me.comboCount >= 5) {
      // Launch on 5+ combo
      foe.launch(8);
    }
  }, 150);
}

function doSpecial(me, foe) {
  if (me.meter < 30) { doAttack(me, foe); return; }
  me.meter -= 30;
  me.state = 'special';
  me.frame = 0;
  me.frameTick = 0;
  me.cooldown = 30;

  // Special effects vary by fighter
  const fx = me.d.id;
  spawnDmg(me.x, me.y - 90, '‚ú®' + me.d.special, me.d.color);

  setTimeout(() => {
    if (!foe.alive || me.dead) return;
    if (me.dist > 160) return;

    let dmg = Math.floor(me.d.atk * 1.4) + rngInt(0, 6);
    dmg = Math.max(1, Math.floor(dmg - foe.d.def * 0.2));

    // Special properties
    if (fx === 'venomqueen') { foe.poison += 4; spawnDmg(foe.x, foe.y-70, 'üß™ÎèÖ!', COL.green); }
    if (fx === 'frostbite') { foe.frozen = 35; spawnDmg(foe.x, foe.y-70, 'üßäÎπôÍ≤∞!', COL.sea); }
    if (fx === 'ironclaw' || fx === 'bonecrusher') { me.armor = 20; }
    if (fx === 'shadowblade') { dmg = Math.floor(dmg * 1.3); } // extra damage
    if (fx === 'hellfire') {
      // Fire AOE
      for (let i = 0; i < 20; i++) {
        particles.push({ x: foe.x+rng(-30,30), y: foe.y+rng(-40,10), vx: rng(-3,3), vy: rng(-5,-1), life: 25, color: pick([COL.orange, COL.red, COL.cream]), size: rng(2,5), grav: -0.1 });
      }
    }
    if (fx === 'berserker') { dmg += Math.floor(me.rage * 0.2); }

    foe.takeDamage(dmg, true);
    foe.knockback(12);
    foe.launch(7);
    spawnBlood(foe.x, foe.y - foe.juggleY, 15);
    shake(8);
    slowmo = 8;
  }, 200);
}

function doSuper(me, foe) {
  if (me.meter < 100) { doSpecial(me, foe); return; }
  me.meter = 0;
  me.state = 'super';
  me.frame = 0;
  me.frameTick = 0;
  me.cooldown = 45;
  me.armor = 30; // super armor during super

  // Super flash
  flashAlpha = 0.8;
  slowmo = 20;
  announce(me.d.super + '!!', 60, 36);

  setTimeout(() => {
    if (!foe.alive || me.dead) return;
    if (me.dist > 200) return;

    let dmg = Math.floor(me.d.atk * 2.5) + rngInt(0, 10);
    dmg = Math.max(5, Math.floor(dmg - foe.d.def * 0.15));

    foe.takeDamage(dmg, false); // unblockable
    foe.knockback(18);
    foe.launch(12);
    spawnBlood(foe.x, foe.y - foe.juggleY, 30);
    spawnSpark(foe.x, foe.y - foe.juggleY - 20, 15, COL.gold);

    // Screen-wide particles
    for (let i = 0; i < 25; i++) {
      particles.push({ x: rng(100,700), y: rng(100,400), vx: rng(-2,2), vy: rng(-3,0), life: 30, color: me.d.color, size: rng(2,6), grav: 0.1 });
    }

    shake(15);
    spawnDmg(foe.x, foe.y - foe.juggleY - 80, 'üíÄ' + dmg, COL.gold);
  }, 350);
}

let comboDisplay = { text: '', timer: 0, x: 0 };
function showCombo(me) {
  comboDisplay = { text: me.comboCount + ' HIT COMBO!', timer: 50, x: me.side === 'left' ? 150 : 550 };
}

// ‚îÄ‚îÄ‚îÄ FATALITY ‚îÄ‚îÄ‚îÄ
function triggerFatality(winner, loser) {
  scene = 'fatality';
  const ftype = pick(FATALITIES);
  loser.state = 'fatality';
  loser.fatalType = ftype;
  loser.fatalFrame = 0;
  loser.dead = true;

  flashAlpha = 1.0;
  slowmo = 30;
  shake(20);
  spawnBlood(loser.x, loser.y, 60);
  announce('üíÄ FATALITY ‚Äî ' + FATALITY_KR[ftype] + ' üíÄ', 120, 40);

  setTimeout(() => {
    winner.state = 'victory';
    winner.frame = 0;
  }, 1500);

  setTimeout(() => {
    scene = 'result';
  }, 4000);
}

// ‚îÄ‚îÄ‚îÄ DRAWING ‚îÄ‚îÄ‚îÄ
function drawArena() {
  // Floor gradient
  const grd = X.createLinearGradient(0, 250, 0, H);
  grd.addColorStop(0, '#0c1220');
  grd.addColorStop(1, '#050F1A');
  X.fillStyle = grd;
  X.fillRect(0, 0, W, H);

  // Arena floor circle
  X.save();
  X.globalAlpha = 0.08;
  X.fillStyle = COL.gold;
  X.beginPath();
  X.ellipse(W/2, 400, 350, 100, 0, 0, Math.PI * 2);
  X.fill();
  X.restore();

  // Arena ring
  X.save();
  X.globalAlpha = 0.2;
  X.strokeStyle = COL.gold;
  X.lineWidth = 2;
  X.beginPath();
  X.ellipse(W/2, 400, 350, 100, 0, 0, Math.PI * 2);
  X.stroke();
  X.restore();

  // Inner ring
  X.save();
  X.globalAlpha = 0.1;
  X.strokeStyle = COL.red;
  X.lineWidth = 1;
  X.beginPath();
  X.ellipse(W/2, 400, 200, 60, 0, 0, Math.PI * 2);
  X.stroke();
  X.restore();

  // Blood stains
  X.save();
  X.globalAlpha = 0.15;
  X.fillStyle = COL.brown;
  bloodStains.forEach(b => {
    X.beginPath();
    X.arc(b.x, b.y, b.r, 0, Math.PI * 2);
    X.fill();
  });
  X.restore();

  // Side pillars
  for (const sx of [30, W - 30]) {
    X.save();
    X.globalAlpha = 0.3;
    X.fillStyle = COL.dark;
    X.fillRect(sx - 8, 150, 16, 300);
    // Torch glow
    X.globalAlpha = 0.15 + Math.sin(tick * 0.05) * 0.05;
    X.fillStyle = COL.orange;
    X.beginPath();
    X.arc(sx, 150, 15, 0, Math.PI * 2);
    X.fill();
    X.restore();
  }
}

function drawHUD() {
  if (!p1 || !p2) return;
  const barW = 250, barH = 14, barY = 20, gap = 25;

  // P1 HP (left, fills right to left)
  const p1x = W/2 - gap - barW;
  drawHPBar(p1x, barY, barW, barH, p1.hp, p1.maxHp, true, p1.d.color);

  // P2 HP (right, fills left to right)
  const p2x = W/2 + gap;
  drawHPBar(p2x, barY, barW, barH, p2.hp, p2.maxHp, false, p2.d.color);

  // Names
  X.font = '14px NeoDGM, monospace';
  X.textAlign = 'right';
  X.fillStyle = p1.d.color;
  X.fillText(p1.d.name, W/2 - gap, barY - 4);
  X.textAlign = 'left';
  X.fillStyle = p2.d.color;
  X.fillText(p2.d.name, W/2 + gap, barY - 4);

  // VS / Round
  X.textAlign = 'center';
  X.font = '12px NeoDGM, monospace';
  X.fillStyle = COL.gold;
  X.fillText('R' + roundNum, W/2, barY + 6);

  // Win markers
  for (let i = 0; i < p1Wins; i++) {
    X.fillStyle = COL.red;
    X.beginPath();
    X.arc(W/2 - gap - 10 - i * 16, barY + barH + 10, 5, 0, Math.PI*2);
    X.fill();
  }
  for (let i = 0; i < p2Wins; i++) {
    X.fillStyle = COL.red;
    X.beginPath();
    X.arc(W/2 + gap + 10 + i * 16, barY + barH + 10, 5, 0, Math.PI*2);
    X.fill();
  }

  // Super meters
  const mW = 120, mH = 6, mY = barY + barH + 6;
  drawMeterBar(W/2 - gap - mW, mY, mW, mH, p1.meter, 100, COL.gold);
  drawMeterBar(W/2 + gap, mY, mW, mH, p2.meter, 100, COL.gold);

  // Meter labels
  X.font = '9px NeoDGM, monospace';
  X.fillStyle = COL.grey;
  X.textAlign = 'right';
  X.fillText('SP', W/2 - gap - mW - 3, mY + 6);
  X.textAlign = 'left';
  X.fillText('SP', W/2 + gap + mW + 3, mY + 6);

  // Timer
  X.textAlign = 'center';
  X.font = '20px NeoDGM, monospace';
  X.fillStyle = COL.cream;
  const timeLeft = Math.max(0, Math.ceil((99 * 60 - tick) / 60));
  X.fillText(String(timeLeft).padStart(2, '0'), W/2, barY + barH + 18);
}

function drawHPBar(x, y, w, h, hp, max, rtl, color) {
  // BG
  X.fillStyle = COL.dark;
  X.fillRect(x, y, w, h);
  // HP fill
  const pct = Math.max(0, hp / max);
  const fillW = w * pct;
  const fillColor = pct > 0.5 ? color : pct > 0.2 ? COL.orange : COL.red;
  if (rtl) {
    X.fillStyle = fillColor;
    X.fillRect(x + w - fillW, y, fillW, h);
  } else {
    X.fillStyle = fillColor;
    X.fillRect(x, y, fillW, h);
  }
  // Border
  X.strokeStyle = COL.wood;
  X.lineWidth = 1;
  X.strokeRect(x, y, w, h);
  // HP text
  X.font = '10px NeoDGM, monospace';
  X.fillStyle = COL.cream;
  X.textAlign = 'center';
  X.fillText(Math.max(0, Math.floor(hp)), x + w/2, y + h - 2);
}

function drawMeterBar(x, y, w, h, val, max, color) {
  X.fillStyle = COL.dark;
  X.fillRect(x, y, w, h);
  const pct = Math.min(1, val / max);
  X.fillStyle = pct >= 1.0 ? COL.cream : color;
  X.fillRect(x, y, w * pct, h);
  if (pct >= 1.0) {
    X.save();
    X.globalAlpha = 0.3 + Math.sin(tick * 0.15) * 0.2;
    X.fillStyle = COL.cream;
    X.fillRect(x, y, w, h);
    X.restore();
  }
  X.strokeStyle = COL.wood;
  X.lineWidth = 0.5;
  X.strokeRect(x, y, w, h);
}

function drawParticles() {
  particles.forEach(p => {
    p.x += p.vx || 0;
    p.y += p.vy || 0;
    if (p.grav) p.vy += p.grav;
    p.life--;
    if (p.life > 0) {
      X.save();
      X.globalAlpha = Math.min(1, p.life / 12);
      X.fillStyle = p.color;
      X.fillRect(Math.floor(p.x), Math.floor(p.y), Math.ceil(p.size), Math.ceil(p.size));
      X.restore();
    }
  });
  particles = particles.filter(p => p.life > 0);
}

function drawDmgTexts() {
  dmgTexts.forEach(d => {
    d.y += d.vy;
    d.life--;
    if (d.life > 0) {
      X.save();
      X.globalAlpha = Math.min(1, d.life / 15);
      X.font = 'bold 14px NeoDGM, monospace';
      X.fillStyle = d.color;
      X.textAlign = 'center';
      X.fillText(d.text, Math.floor(d.x), Math.floor(d.y));
      X.restore();
    }
  });
  dmgTexts = dmgTexts.filter(d => d.life > 0);
}

function drawAnnounce() {
  if (announceTimer <= 0) return;
  announceTimer--;
  X.save();
  X.globalAlpha = Math.min(1, announceTimer / 15);
  X.font = announceSize + 'px NeoDGM, monospace';
  X.textAlign = 'center';
  X.fillStyle = COL.red;
  X.shadowColor = COL.red;
  X.shadowBlur = 20;
  X.fillText(announceText, W/2, H/2 - 20);
  X.restore();
}

function drawFlash() {
  if (flashAlpha > 0) {
    X.save();
    X.globalAlpha = flashAlpha;
    X.fillStyle = '#fff';
    X.fillRect(0, 0, W, H);
    X.restore();
    flashAlpha -= 0.05;
  }
}

function drawCombo() {
  if (comboDisplay.timer <= 0) return;
  comboDisplay.timer--;
  X.save();
  X.globalAlpha = Math.min(1, comboDisplay.timer / 10);
  X.font = '28px NeoDGM, monospace';
  X.textAlign = 'center';
  X.fillStyle = COL.orange;
  X.shadowColor = COL.orange;
  X.shadowBlur = 10;
  X.fillText(comboDisplay.text, comboDisplay.x, 130);
  X.restore();
}

// ‚îÄ‚îÄ‚îÄ SCENES ‚îÄ‚îÄ‚îÄ

// TITLE
function drawTitle() {
  drawArena();
  X.save();
  X.textAlign = 'center';

  // Title
  X.font = '42px NeoDGM, monospace';
  X.fillStyle = COL.red;
  X.shadowColor = COL.red;
  X.shadowBlur = 20;
  X.fillText('‚öîÔ∏è AI ÏΩúÎ°úÏÑ∏ÏõÄ', W/2, 160);
  X.shadowBlur = 0;

  X.font = '18px NeoDGM, monospace';
  X.fillStyle = COL.cream;
  X.fillText('PIXEL DEATH ARENA', W/2, 195);

  X.font = '14px NeoDGM, monospace';
  X.fillStyle = COL.gold;
  X.fillText('Í¥ÄÏ†Ñ Ï†ÑÏö© ¬∑ AI vs AI ¬∑ ÏûêÎèô Ï†ÑÌà¨ ¬∑ ÏÑ±Ïù∏Ïö© Í≥†Ïñ¥', W/2, 230);

  // Fighter showcase (cycle)
  const showIdx = Math.floor(tick / 90) % FIGHTERS.length;
  const sf = FIGHTERS[showIdx];
  const idleImg = imgCache[ASSET + sf.id + '/idle.png'];
  if (idleImg) {
    X.save();
    X.globalAlpha = 0.7 + Math.sin(tick * 0.03) * 0.3;
    X.drawImage(idleImg, W/2 - 64, 260, 128, 128);
    X.restore();
  }
  X.font = '12px NeoDGM, monospace';
  X.fillStyle = sf.color;
  X.fillText(sf.name + ' ‚Äî ' + sf.weapon, W/2, 408);

  // Blink "click to start"
  if (Math.floor(tick / 30) % 2 === 0) {
    X.font = '16px NeoDGM, monospace';
    X.fillStyle = COL.cream;
    X.fillText('[ ÌÅ¥Î¶≠ÌïòÏó¨ ÏãúÏûë ]', W/2, 450);
  }

  X.font = '11px NeoDGM, monospace';
  X.fillStyle = COL.grey;
  X.fillText('üÉè Ìè¨Ïª§ ÏïÑÎ†àÎÇò: /', W/2, 480);

  X.restore();
}

// SELECT SCREEN
function drawSelect() {
  drawArena();
  X.save();
  X.textAlign = 'center';
  X.font = '20px NeoDGM, monospace';
  X.fillStyle = COL.gold;
  X.fillText('‚öîÔ∏è FIGHTER SELECT', W/2, 40);

  // Grid of 8 fighters (2 rows √ó 4)
  const cols = 4, cellW = 160, cellH = 160;
  const startX = (W - cols * cellW) / 2;
  const startY = 60;

  FIGHTERS.forEach((f, i) => {
    const col = i % cols, row = Math.floor(i / cols);
    const cx = startX + col * cellW + cellW/2;
    const cy = startY + row * cellH + cellH/2;

    // Highlight selected
    const isP1 = (i === selectP1);
    const isP2 = (i === selectP2);
    if (isP1 || isP2) {
      X.save();
      X.strokeStyle = isP1 ? COL.red : COL.sea;
      X.lineWidth = 2;
      X.shadowColor = isP1 ? COL.red : COL.sea;
      X.shadowBlur = 10;
      X.strokeRect(cx - cellW/2 + 10, cy - cellH/2 + 5, cellW - 20, cellH - 10);
      X.restore();
      // Label
      X.font = '10px NeoDGM, monospace';
      X.fillStyle = isP1 ? COL.red : COL.sea;
      X.fillText(isP1 ? '1P' : '2P', cx, cy - cellH/2 + 16);
    }

    // Fighter portrait
    const img = imgCache[ASSET + f.id + '/idle.png'];
    if (img) {
      X.drawImage(img, cx - 40, cy - 45, 80, 80);
    }
    X.font = '11px NeoDGM, monospace';
    X.fillStyle = f.color;
    X.fillText(f.name, cx, cy + 48);
    X.font = '9px NeoDGM, monospace';
    X.fillStyle = COL.grey;
    X.fillText(f.weapon + ' | ATK:' + f.atk + ' SPD:' + f.spd, cx, cy + 62);
  });

  // Timer for auto-select
  selectTimer++;
  if (selectTimer > 120) { // auto-select after 2 seconds
    startMatch();
  }

  // VS display
  X.font = '14px NeoDGM, monospace';
  X.fillStyle = COL.cream;
  X.fillText(FIGHTERS[selectP1].name + '  ‚öîÔ∏è  ' + FIGHTERS[selectP2].name, W/2, H - 30);
  X.font = '10px NeoDGM, monospace';
  X.fillStyle = COL.grey;
  X.fillText('ÏûêÎèô ÏÑ†ÌÉù Ï§ë...', W/2, H - 12);

  X.restore();
}

// LOADING
function drawLoading() {
  X.fillStyle = COL.bg;
  X.fillRect(0, 0, W, H);
  X.textAlign = 'center';
  X.font = '16px NeoDGM, monospace';
  X.fillStyle = COL.cream;
  X.fillText('ÏóêÏÖã Î°úÎî© Ï§ë... ' + loaded + '/' + totalLoad, W/2, H/2);

  // Loading bar
  const bw = 300, bh = 12;
  X.fillStyle = COL.dark;
  X.fillRect(W/2-bw/2, H/2+15, bw, bh);
  X.fillStyle = COL.gold;
  X.fillRect(W/2-bw/2, H/2+15, bw * (loaded/Math.max(1,totalLoad)), bh);
}

// INTRO (ROUND START)
let introTimer = 0;
function drawIntro() {
  drawArena();
  if (p1) p1.draw();
  if (p2) p2.draw();
  drawHUD();

  introTimer++;

  X.save();
  X.textAlign = 'center';

  if (introTimer < 60) {
    X.font = '36px NeoDGM, monospace';
    X.fillStyle = COL.gold;
    X.shadowColor = COL.gold;
    X.shadowBlur = 15;
    X.fillText('ROUND ' + roundNum, W/2, H/2 - 20);
  } else if (introTimer < 100) {
    X.font = '48px NeoDGM, monospace';
    X.fillStyle = COL.red;
    X.shadowColor = COL.red;
    X.shadowBlur = 20;
    X.fillText('FIGHT!', W/2, H/2 - 10);
  } else {
    scene = 'fighting';
    tick = 0;
  }
  X.restore();
}

// ‚îÄ‚îÄ‚îÄ MAIN LOOP ‚îÄ‚îÄ‚îÄ
function loop() {
  tick++;

  // Slowmo
  if (slowmo > 0) {
    slowmo--;
    if (tick % 3 !== 0) { requestAnimationFrame(loop); return; }
  }

  X.clearRect(0, 0, W, H);

  // Shake
  if (shakeDur > 0) {
    shakeX = (Math.random()-0.5) * shakeDur * 0.8;
    shakeY = (Math.random()-0.5) * shakeDur * 0.8;
    shakeDur--;
  } else { shakeX = 0; shakeY = 0; }

  X.save();
  X.translate(shakeX, shakeY);

  switch(scene) {
    case 'title':
      drawTitle();
      break;

    case 'select':
      drawSelect();
      break;

    case 'loading':
      drawLoading();
      break;

    case 'intro':
      drawIntro();
      break;

    case 'fighting':
      drawArena();
      // AI decisions
      if (tick % Math.max(3, 15 - p1.d.spd) === 0) execAction(p1, p2, aiBrain(p1, p2));
      if (tick % Math.max(3, 15 - p2.d.spd) === 0) execAction(p2, p1, aiBrain(p2, p1));

      p1.update(); p2.update();

      // Draw y-sorted
      [p1, p2].sort((a,b) => a.y - b.y).forEach(f => f.draw());
      drawParticles();
      drawDmgTexts();
      drawHUD();
      drawCombo();
      drawAnnounce();

      // Check KO
      if (p1.hp <= 0 && !p1.dead) {
        p1.hp = 0;
        const perfect = p2.hp === p2.maxHp;
        if (perfect) announce('PERFECT!', 80, 42);
        // Low HP = FATALITY, otherwise normal KO
        if (p1.hp <= -10 || Math.random() < 0.4) {
          triggerFatality(p2, p1);
        } else {
          p1.state = 'death'; p1.frame = 0; p1.dead = true;
          p2.state = 'victory'; p2.frame = 0;
          announce('K.O.!', 80, 52);
          shake(10);
          flashAlpha = 0.6;
          setTimeout(() => { p2Wins++; goNextRound(); }, 3000);
        }
      }
      if (p2.hp <= 0 && !p2.dead) {
        p2.hp = 0;
        const perfect = p1.hp === p1.maxHp;
        if (perfect) announce('PERFECT!', 80, 42);
        if (p2.hp <= -10 || Math.random() < 0.4) {
          triggerFatality(p1, p2);
        } else {
          p2.state = 'death'; p2.frame = 0; p2.dead = true;
          p1.state = 'victory'; p1.frame = 0;
          announce('K.O.!', 80, 52);
          shake(10);
          flashAlpha = 0.6;
          setTimeout(() => { p1Wins++; goNextRound(); }, 3000);
        }
      }

      // Timeout
      if (tick >= 99 * 60) {
        // HP comparison
        const p1pct = p1.hp / p1.maxHp;
        const p2pct = p2.hp / p2.maxHp;
        announce('TIME UP!', 80, 42);
        if (p1pct > p2pct) { p2.dead = true; p1Wins++; }
        else if (p2pct > p1pct) { p1.dead = true; p2Wins++; }
        else { /* draw ‚Äî both get a point */ p1Wins++; p2Wins++; }
        setTimeout(() => goNextRound(), 2000);
      }
      break;

    case 'fatality':
      drawArena();
      p1.update(); p2.update();
      [p1, p2].sort((a,b) => a.y - b.y).forEach(f => f.draw());
      drawParticles();
      drawDmgTexts();
      drawHUD();
      drawAnnounce();
      break;

    case 'result':
      drawResult();
      break;
  }

  drawFlash();
  X.restore();

  requestAnimationFrame(loop);
}

function goNextRound() {
  // Check match winner (best of 3)
  if (p1Wins >= 2 || p2Wins >= 2) {
    scene = 'result';
    return;
  }
  roundNum++;
  // Reset fighters for new round
  p1.hp = p1.maxHp; p1.meter = 0; p1.dead = false; p1.state = 'idle'; p1.frame = 0;
  p1.x = 120; p1.juggleY = 0; p1.airborne = false; p1.poison = 0; p1.frozen = 0; p1.comboCount = 0;
  p2.hp = p2.maxHp; p2.meter = 0; p2.dead = false; p2.state = 'idle'; p2.frame = 0;
  p2.x = 680; p2.juggleY = 0; p2.airborne = false; p2.poison = 0; p2.frozen = 0; p2.comboCount = 0;
  bloodStains = []; particles = []; dmgTexts = [];
  introTimer = 0;
  scene = 'intro';
}

function drawResult() {
  drawArena();
  if (p1) p1.draw();
  if (p2) p2.draw();
  drawParticles();

  X.save();
  X.textAlign = 'center';

  const winner = p1Wins >= 2 ? p1 : p2;
  const loser = p1Wins >= 2 ? p2 : p1;

  // Dark overlay
  X.fillStyle = 'rgba(5,15,26,0.7)';
  X.fillRect(0, 0, W, H);

  X.font = '36px NeoDGM, monospace';
  X.fillStyle = COL.gold;
  X.shadowColor = COL.gold;
  X.shadowBlur = 20;
  X.fillText('üèÜ ' + winner.d.name + ' ÏäπÎ¶¨!', W/2, 140);
  X.shadowBlur = 0;

  X.font = '16px NeoDGM, monospace';
  X.fillStyle = COL.cream;
  X.fillText(winner.d.weapon + ' | ' + p1Wins + ' ‚Äî ' + p2Wins, W/2, 175);

  // Winner portrait
  const wimg = imgCache[ASSET + winner.d.id + '/idle.png'];
  if (wimg) {
    X.drawImage(wimg, W/2 - 64, 200, 128, 128);
  }

  // Stats
  X.font = '12px NeoDGM, monospace';
  X.fillStyle = COL.grey;
  X.fillText('ROUND ' + roundNum + ' ¬∑ BEST OF 3', W/2, 360);

  // Blink restart
  if (Math.floor(tick / 25) % 2 === 0) {
    X.font = '16px NeoDGM, monospace';
    X.fillStyle = COL.cream;
    X.fillText('[ ÌÅ¥Î¶≠ÌïòÏó¨ Ïû¨ÏãúÏûë ]', W/2, 410);
  }

  X.font = '11px NeoDGM, monospace';
  X.fillStyle = COL.sea;
  X.fillText('üÉè Ìè¨Ïª§ ÏïÑÎ†àÎÇò: /', W/2, 450);

  X.restore();
}

// ‚îÄ‚îÄ‚îÄ START ‚îÄ‚îÄ‚îÄ
async function startMatch() {
  scene = 'loading';
  f1Data = FIGHTERS[selectP1];
  f2Data = FIGHTERS[selectP2];
  await Promise.all([preloadFighter(f1Data), preloadFighter(f2Data)]);

  p1 = new Fighter(f1Data, 'left');
  p2 = new Fighter(f2Data, 'right');
  p1.setEnemy(p2);
  p2.setEnemy(p1);
  p1Wins = 0; p2Wins = 0; roundNum = 1;
  bloodStains = []; particles = []; dmgTexts = [];
  introTimer = 0;
  scene = 'intro';
}

function initTitle() {
  // Preload idle portraits for title/select
  Promise.all(FIGHTERS.map(f => loadImg(ASSET + f.id + '/idle.png')));
}

// Click handler
C.addEventListener('click', () => {
  if (scene === 'title') {
    // Random matchup
    const indices = [...Array(8).keys()].sort(() => Math.random() - 0.5);
    selectP1 = indices[0];
    selectP2 = indices[1];
    selectTimer = 0;
    scene = 'select';
  } else if (scene === 'result') {
    // New random matchup
    const indices = [...Array(8).keys()].sort(() => Math.random() - 0.5);
    selectP1 = indices[0];
    selectP2 = indices[1];
    selectTimer = 0;
    scene = 'select';
  }
});

initTitle();
loop();
</script>
</body>
</html>
