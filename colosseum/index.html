<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ğŸ—¡ï¸ AI ì½œë¡œì„¸ì›€ â€” FATALITY</title>
<style>
@font-face{font-family:'NeoDGM';src:url('/static/fonts/neodgm.woff2') format('woff2');font-display:swap}
*{margin:0;padding:0;box-sizing:border-box}
body{background:#050F1A;color:#FCC88E;font-family:'NeoDGM',monospace;overflow:hidden;height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center}
canvas{image-rendering:pixelated;border:2px solid #9D7F33;background:#0a0f1a}
#hud{position:fixed;top:0;left:0;right:0;display:flex;justify-content:space-between;padding:8px 20px;background:rgba(5,15,26,0.9);border-bottom:1px solid #9D7F33;z-index:10;font-size:14px}
.hp-bar{width:200px;height:16px;background:#221C20;border:1px solid #704637;border-radius:2px;overflow:hidden}
.hp-fill{height:100%;transition:width 0.3s;border-radius:1px}
.hp-p1{background:linear-gradient(90deg,#D24C59,#F09858)}
.hp-p2{background:linear-gradient(90deg,#35B97D,#69B5A8)}
#p1-info,#p2-info{display:flex;align-items:center;gap:8px}
#p2-info{flex-direction:row-reverse}
.fighter-name{font-size:16px;font-weight:bold}
#center-info{text-align:center}
#round-num{font-size:18px;color:#9D7F33}
#fight-msg{font-size:12px;color:#938B7B;margin-top:2px}
#overlay{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:20;background:rgba(5,15,26,0.95);transition:opacity 0.5s}
#overlay.hidden{opacity:0;pointer-events:none}
#overlay h1{font-size:48px;color:#D24C59;text-shadow:0 0 20px rgba(210,76,89,0.5);margin-bottom:8px}
#overlay h2{font-size:24px;color:#FCC88E;margin-bottom:20px}
#matchup{display:flex;align-items:center;gap:40px;margin:20px 0}
.matchup-fighter{text-align:center}
.matchup-fighter img{width:128px;height:128px;image-rendering:pixelated}
.matchup-fighter .name{font-size:18px;margin-top:8px}
#vs{font-size:36px;color:#D24C59;text-shadow:0 0 15px #D24C59}
#start-btn{margin-top:20px;padding:12px 40px;font-size:18px;font-family:'NeoDGM',monospace;background:#D24C59;color:#FCC88E;border:2px solid #9D7F33;cursor:pointer;transition:all 0.2s}
#start-btn:hover{background:#F09858;transform:scale(1.05)}
#fatality-text{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);font-size:64px;color:#D24C59;text-shadow:0 0 30px #D24C59,0 0 60px rgba(210,76,89,0.5);z-index:30;display:none;animation:fatalShake 0.5s ease-out}
@keyframes fatalShake{0%{transform:translate(-50%,-50%) scale(3);opacity:0}50%{transform:translate(-50%,-50%) scale(1.1);opacity:1}100%{transform:translate(-50%,-50%) scale(1)}}
#ko-flash{position:fixed;inset:0;background:#D24C59;z-index:25;opacity:0;pointer-events:none;transition:opacity 0.1s}
#blood-overlay{position:fixed;inset:0;z-index:15;pointer-events:none;opacity:0;background:radial-gradient(circle at 50% 50%,transparent 30%,rgba(210,76,89,0.3) 100%);transition:opacity 0.5s}
#combo-text{position:fixed;top:30%;right:10%;font-size:32px;color:#F09858;text-shadow:0 0 10px #F09858;z-index:15;display:none}
a{color:#69B5A8;text-decoration:none}
</style>
</head>
<body>

<div id="hud">
  <div id="p1-info">
    <div class="fighter-name" id="p1-name">???</div>
    <div class="hp-bar"><div class="hp-fill hp-p1" id="p1-hp" style="width:100%"></div></div>
    <span id="p1-hp-text">100</span>
  </div>
  <div id="center-info">
    <div id="round-num">ROUND 1</div>
    <div id="fight-msg">ëŒ€ê¸° ì¤‘...</div>
  </div>
  <div id="p2-info">
    <div class="fighter-name" id="p2-name">???</div>
    <div class="hp-bar"><div class="hp-fill hp-p2" id="p2-hp" style="width:100%"></div></div>
    <span id="p2-hp-text">100</span>
  </div>
</div>

<canvas id="arena" width="800" height="500"></canvas>

<div id="fatality-text">ğŸ’€ FATALITY ğŸ’€</div>
<div id="ko-flash"></div>
<div id="blood-overlay"></div>
<div id="combo-text"></div>

<div id="overlay">
  <h1>âš”ï¸ AI ì½œë¡œì„¸ì›€</h1>
  <h2>PIXEL DEATH ARENA</h2>
  <div id="matchup">
    <div class="matchup-fighter">
      <img id="mu-p1-img" src="">
      <div class="name" id="mu-p1-name">???</div>
    </div>
    <div id="vs">VS</div>
    <div class="matchup-fighter">
      <img id="mu-p2-img" src="">
      <div class="name" id="mu-p2-name">???</div>
    </div>
  </div>
  <button id="start-btn" onclick="startFight()">âš”ï¸ FIGHT</button>
  <div style="margin-top:12px;font-size:12px;color:#938B7B">ê´€ì „ ì „ìš© Â· AI vs AI ìë™ ì „íˆ¬ Â· ì„±ì¸ìš© ê³ ì–´</div>
  <div style="margin-top:8px"><a href="/">ğŸƒ í¬ì»¤ ì•„ë ˆë‚˜ë¡œ ëŒì•„ê°€ê¸°</a></div>
</div>

<script>
const FIGHTERS = [
  {id:'bloodfang',   name:'ë¸”ëŸ¬ë“œíŒ¡',     name_en:'BloodFang',    weapon:'ë„ë¼',  color:'#D24C59', style:'aggressive', baseAtk:18, baseDef:8,  baseSpd:12, hp:110},
  {id:'ironclaw',    name:'ì•„ì´ì–¸í´ë¡œ',   name_en:'IronClaw',     weapon:'ì² í‡´',  color:'#938B7B', style:'tank',       baseAtk:14, baseDef:16, baseSpd:8,  hp:140},
  {id:'shadowblade', name:'ì‰ë„ìš°ë¸”ë ˆì´ë“œ',name_en:'ShadowBlade', weapon:'ìŒë‹¨ê²€',color:'#073935', style:'assassin',   baseAtk:20, baseDef:6,  baseSpd:18, hp:90},
  {id:'berserker',   name:'ë²„ì„œì»¤',       name_en:'Berserker',    weapon:'ì¹´íƒ€ë‚˜',color:'#D24C59', style:'berserker',  baseAtk:22, baseDef:5,  baseSpd:15, hp:95},
  {id:'bonecrusher', name:'ë³¸í¬ëŸ¬ì…”',     name_en:'BoneCrusher',  weapon:'í•´ë¨¸',  color:'#704637', style:'tank',       baseAtk:16, baseDef:14, baseSpd:6,  hp:130},
  {id:'venomqueen',  name:'ë² ë†ˆí€¸',       name_en:'VenomQueen',   weapon:'ë…ê²€',  color:'#126D65', style:'dot',        baseAtk:12, baseDef:10, baseSpd:14, hp:100},
  {id:'hellfire',    name:'í—¬íŒŒì´ì–´',     name_en:'HellFire',     weapon:'í™”ì—¼ê²€',color:'#F09858', style:'burst',      baseAtk:20, baseDef:7,  baseSpd:13, hp:100},
  {id:'frostbite',   name:'í”„ë¡œìŠ¤íŠ¸ë°”ì´íŠ¸',name_en:'FrostBite',   weapon:'ë¹™ê²°ì°½',color:'#69B5A8', style:'control',    baseAtk:13, baseDef:12, baseSpd:10, hp:115},
];

const FATALITIES = ['head_off','bisect','explode','impale','spine_rip','dissolve'];
const FATALITY_NAMES = {
  head_off:'ì°¸ìˆ˜',bisect:'ì–‘ë‹¨',explode:'í­ì‚¬',impale:'ê´€í†µ',spine_rip:'ì²™ì¶” ë½‘ê¸°',dissolve:'ìš©í•´'
};
const ANIMS = ['walk','attack','hit','death','victory'];
const ASSET_BASE = '/colosseum/assets/';

const canvas = document.getElementById('arena');
const ctx = canvas.getContext('2d');

// Preload images
const imgCache = {};
function loadImg(path) {
  if (imgCache[path]) return Promise.resolve(imgCache[path]);
  return new Promise((res, rej) => {
    const img = new Image();
    img.onload = () => { imgCache[path] = img; res(img); };
    img.onerror = () => rej(path);
    img.src = path;
  });
}

async function preloadFighter(f) {
  const base = ASSET_BASE + f.id + '/';
  const promises = [loadImg(base + 'idle.png'), loadImg(base + 'idle_64.png')];
  for (const anim of ANIMS) {
    for (let i = 0; i < 4; i++) promises.push(loadImg(base + anim + '_' + i + '.png'));
  }
  for (const fat of FATALITIES) {
    for (let i = 0; i < 4; i++) promises.push(loadImg(base + 'fatal_' + fat + '_' + i + '.png'));
  }
  await Promise.all(promises);
}

// Game state
let p1, p2, gameState = 'menu', round = 1, tick = 0;
let particles = [], shakeX = 0, shakeY = 0, shakeDur = 0;
let combo = { p1: 0, p2: 0 };

class Fighter {
  constructor(data, side) {
    this.data = data;
    this.side = side; // 'left' or 'right'
    this.x = side === 'left' ? 150 : 550;
    this.y = 300;
    this.hp = data.hp;
    this.maxHp = data.hp;
    this.atk = data.baseAtk;
    this.def = data.baseDef;
    this.spd = data.baseSpd;
    this.state = 'idle'; // idle, walk, attack, hit, death, victory, fatality
    this.frame = 0;
    this.frameTick = 0;
    this.facing = side === 'left' ? 1 : -1;
    this.targetX = this.x;
    this.cooldown = 0;
    this.poison = 0;
    this.frozen = 0;
    this.rage = 0; // berserker mechanic
    this.fatalityType = null;
    this.fatalityFrame = 0;
    this.dead = false;
    this.actionQueue = [];
    this.stagger = 0;
  }

  get basePath() { return ASSET_BASE + this.data.id + '/'; }

  getImg() {
    if (this.state === 'idle') {
      return imgCache[this.basePath + 'idle_64.png'];
    }
    if (this.state === 'fatality') {
      const key = this.basePath + 'fatal_' + this.fatalityType + '_' + Math.min(this.fatalityFrame, 3) + '.png';
      return imgCache[key];
    }
    const f = Math.min(this.frame, 3);
    return imgCache[this.basePath + this.state + '_' + f + '.png'];
  }

  draw(ctx) {
    const img = this.getImg();
    if (!img) return;
    const size = this.state === 'idle' ? 128 : 128; // draw at 2x for 64px sprites
    const drawW = this.state === 'idle' ? 128 : 128;
    const drawH = this.state === 'idle' ? 128 : 128;
    ctx.save();
    ctx.translate(this.x, this.y);
    if (this.facing < 0) ctx.scale(-1, 1);
    // Flash white on hit
    if (this.state === 'hit' && this.frame < 2) {
      ctx.globalAlpha = 0.7 + Math.sin(tick * 0.5) * 0.3;
    }
    // Frozen tint
    if (this.frozen > 0) {
      ctx.filter = 'hue-rotate(180deg) brightness(1.3)';
    }
    // Rage red tint
    if (this.rage > 30) {
      ctx.filter = `brightness(${1 + this.rage * 0.005}) saturate(${1 + this.rage * 0.02})`;
    }
    const srcW = img.width, srcH = img.height;
    ctx.drawImage(img, -drawW/2, -drawH/2, drawW, drawH);
    ctx.restore();

    // Shadow
    ctx.save();
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.ellipse(this.x, this.y + 55, 30, 8, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // HP bar above
    if (!this.dead && this.state !== 'fatality') {
      const bw = 60, bh = 5;
      const bx = this.x - bw/2, by = this.y - 75;
      ctx.fillStyle = '#221C20';
      ctx.fillRect(bx, by, bw, bh);
      const pct = Math.max(0, this.hp / this.maxHp);
      ctx.fillStyle = pct > 0.5 ? '#35B97D' : pct > 0.2 ? '#F09858' : '#D24C59';
      ctx.fillRect(bx, by, bw * pct, bh);
      ctx.strokeStyle = '#704637';
      ctx.strokeRect(bx, by, bw, bh);
    }

    // Poison particles
    if (this.poison > 0) {
      for (let i = 0; i < 2; i++) {
        particles.push({
          x: this.x + (Math.random()-0.5)*40,
          y: this.y + (Math.random()-0.5)*40,
          vx: (Math.random()-0.5)*2,
          vy: -1-Math.random(),
          life: 20,
          color: '#126D65',
          size: 3
        });
      }
    }
  }

  update() {
    this.frameTick++;
    if (this.cooldown > 0) this.cooldown--;
    if (this.stagger > 0) this.stagger--;
    if (this.frozen > 0) this.frozen--;

    // Animation frame advance
    const spd = this.state === 'attack' ? 6 : this.state === 'fatality' ? 12 : 8;
    if (this.frameTick >= spd) {
      this.frameTick = 0;
      if (this.state === 'fatality') {
        if (this.fatalityFrame < 3) this.fatalityFrame++;
      } else if (this.state === 'death') {
        if (this.frame < 3) this.frame++;
      } else if (this.state === 'victory') {
        this.frame = (this.frame + 1) % 4;
      } else if (this.state !== 'idle') {
        this.frame++;
        if (this.frame >= 4) {
          this.state = 'idle';
          this.frame = 0;
        }
      }
    }

    // Move toward target
    if (Math.abs(this.x - this.targetX) > 2) {
      this.x += (this.targetX - this.x) * 0.1;
      if (this.state === 'idle') this.state = 'walk';
    }

    // Poison tick
    if (this.poison > 0 && tick % 30 === 0) {
      this.hp -= 2;
      this.poison--;
      spawnDmgText(this.x, this.y - 60, 'ğŸ§ª2', '#126D65');
    }

    // Berserker rage
    if (this.data.style === 'berserker') {
      this.rage = Math.max(0, ((this.maxHp - this.hp) / this.maxHp) * 100);
      this.atk = this.data.baseAtk + Math.floor(this.rage * 0.15);
    }
  }
}

// Damage text particles
const dmgTexts = [];
function spawnDmgText(x, y, text, color) {
  dmgTexts.push({ x, y, text, color, life: 40, vy: -2 });
}

// Blood particles
function spawnBlood(x, y, count) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y: y + (Math.random()-0.5)*20,
      vx: (Math.random()-0.5) * 8,
      vy: -2 - Math.random() * 6,
      life: 30 + Math.random() * 30,
      color: Math.random() > 0.3 ? '#D24C59' : '#4D2C2C',
      size: 2 + Math.random() * 4,
      gravity: 0.3
    });
  }
}

function screenShake(dur) {
  shakeDur = dur;
}

// AI decision
function aiDecide(me, enemy) {
  if (me.cooldown > 0 || me.stagger > 0 || me.frozen > 0) return null;
  const dist = Math.abs(me.x - enemy.x);
  const style = me.data.style;

  // Attack range
  if (dist < 120) {
    // In range â€” attack or dodge
    const r = Math.random();
    if (style === 'aggressive') return r < 0.7 ? 'attack' : 'dodge';
    if (style === 'tank') return r < 0.5 ? 'attack' : r < 0.8 ? 'block' : 'dodge';
    if (style === 'assassin') return r < 0.6 ? 'attack' : r < 0.9 ? 'dodge' : 'attack';
    if (style === 'berserker') return me.rage > 50 ? 'attack' : r < 0.65 ? 'attack' : 'dodge';
    if (style === 'dot') return r < 0.5 ? 'attack' : 'poison';
    if (style === 'burst') return r < 0.55 ? 'attack' : r < 0.8 ? 'special' : 'dodge';
    if (style === 'control') return r < 0.45 ? 'attack' : r < 0.7 ? 'freeze' : 'dodge';
    return r < 0.6 ? 'attack' : 'dodge';
  }

  // Out of range â€” approach
  return 'approach';
}

function executeAction(me, enemy, action) {
  if (!action) return;

  if (action === 'approach') {
    me.targetX += me.facing * 40;
    me.state = 'walk';
    me.frame = 0;
    me.cooldown = 10;
  }
  else if (action === 'dodge') {
    me.targetX -= me.facing * 60;
    me.targetX = Math.max(80, Math.min(720, me.targetX));
    me.cooldown = 15;
  }
  else if (action === 'attack') {
    me.state = 'attack';
    me.frame = 0;
    me.cooldown = Math.max(8, 25 - me.spd);
    // Calculate hit
    setTimeout(() => {
      if (enemy.dead) return;
      const dist = Math.abs(me.x - enemy.x);
      if (dist > 140) { spawnDmgText(enemy.x, enemy.y-60, 'MISS', '#938B7B'); return; }
      const dodge = Math.random() < (enemy.spd * 0.01);
      if (dodge) { spawnDmgText(enemy.x, enemy.y-60, 'DODGE', '#69B5A8'); return; }
      let dmg = me.atk + Math.floor(Math.random() * 6) - Math.floor(enemy.def * 0.4);
      const crit = Math.random() < 0.15;
      if (crit) dmg = Math.floor(dmg * 1.8);
      dmg = Math.max(1, dmg);
      enemy.hp -= dmg;
      enemy.state = 'hit';
      enemy.frame = 0;
      enemy.stagger = 8;
      const side = me.side === 'left' ? 'p1' : 'p2';
      combo[side]++;
      spawnDmgText(enemy.x, enemy.y - 70, (crit ? 'ğŸ’¥' : '') + dmg, crit ? '#F09858' : '#D24C59');
      spawnBlood(enemy.x, enemy.y, crit ? 20 : 8);
      screenShake(crit ? 8 : 4);
      if (combo[side] >= 3) {
        showCombo(combo[side]);
      }
      // Reset other side combo
      combo[side === 'p1' ? 'p2' : 'p1'] = 0;
      updateHUD();
    }, 200);
  }
  else if (action === 'poison' && me.data.style === 'dot') {
    me.state = 'attack';
    me.frame = 0;
    me.cooldown = 35;
    setTimeout(() => {
      if (Math.abs(me.x - enemy.x) < 150) {
        enemy.poison += 5;
        spawnDmgText(enemy.x, enemy.y - 60, 'ğŸ§ªë…!', '#126D65');
      }
    }, 200);
  }
  else if (action === 'freeze' && me.data.style === 'control') {
    me.state = 'attack';
    me.frame = 0;
    me.cooldown = 40;
    setTimeout(() => {
      if (Math.abs(me.x - enemy.x) < 150) {
        enemy.frozen = 40;
        spawnDmgText(enemy.x, enemy.y - 60, 'ğŸ§Šë¹™ê²°!', '#69B5A8');
      }
    }, 200);
  }
  else if (action === 'special' && me.data.style === 'burst') {
    me.state = 'attack';
    me.frame = 0;
    me.cooldown = 30;
    setTimeout(() => {
      if (Math.abs(me.x - enemy.x) < 160) {
        const dmg = Math.floor(me.atk * 1.5);
        enemy.hp -= dmg;
        enemy.state = 'hit';
        enemy.frame = 0;
        enemy.stagger = 12;
        spawnDmgText(enemy.x, enemy.y - 70, 'ğŸ”¥' + dmg, '#F09858');
        spawnBlood(enemy.x, enemy.y, 25);
        screenShake(10);
        // Fire particles
        for (let i = 0; i < 15; i++) {
          particles.push({
            x: enemy.x + (Math.random()-0.5)*40,
            y: enemy.y + (Math.random()-0.5)*40,
            vx: (Math.random()-0.5)*4,
            vy: -3 - Math.random()*3,
            life: 25, color: Math.random()>0.5?'#F09858':'#D24C59', size: 4
          });
        }
        updateHUD();
      }
    }, 250);
  }
  else if (action === 'block') {
    me.def = me.data.baseDef * 2;
    me.cooldown = 20;
    setTimeout(() => { me.def = me.data.baseDef; }, 600);
    spawnDmgText(me.x, me.y - 60, 'ğŸ›¡ï¸', '#938B7B');
  }
}

function showCombo(n) {
  const el = document.getElementById('combo-text');
  el.textContent = `${n} COMBO!`;
  el.style.display = 'block';
  setTimeout(() => el.style.display = 'none', 800);
}

function updateHUD() {
  const p1pct = Math.max(0, p1.hp / p1.maxHp * 100);
  const p2pct = Math.max(0, p2.hp / p2.maxHp * 100);
  document.getElementById('p1-hp').style.width = p1pct + '%';
  document.getElementById('p2-hp').style.width = p2pct + '%';
  document.getElementById('p1-hp-text').textContent = Math.max(0, Math.floor(p1.hp));
  document.getElementById('p2-hp-text').textContent = Math.max(0, Math.floor(p2.hp));
}

async function triggerFatality(winner, loser) {
  gameState = 'fatality';
  const ftype = FATALITIES[Math.floor(Math.random() * FATALITIES.length)];

  // Flash
  const flash = document.getElementById('ko-flash');
  flash.style.opacity = '1';
  setTimeout(() => flash.style.opacity = '0', 150);

  // Blood overlay
  document.getElementById('blood-overlay').style.opacity = '1';

  // Show fatality text
  const ftext = document.getElementById('fatality-text');
  ftext.textContent = `ğŸ’€ ${FATALITY_NAMES[ftype]} ğŸ’€`;
  ftext.style.display = 'block';
  ftext.style.animation = 'none';
  ftext.offsetHeight; // reflow
  ftext.style.animation = 'fatalShake 0.5s ease-out';

  // Loser plays fatality anim
  loser.state = 'fatality';
  loser.fatalityType = ftype;
  loser.fatalityFrame = 0;
  loser.dead = true;

  // Massive blood
  spawnBlood(loser.x, loser.y, 50);
  screenShake(20);

  document.getElementById('fight-msg').textContent =
    `${winner.data.name}ì˜ ${FATALITY_NAMES[ftype]}!! ${loser.data.name} ì²˜í˜•!!`;

  // Winner victory after delay
  setTimeout(() => {
    winner.state = 'victory';
    winner.frame = 0;
  }, 1500);

  // Show restart after delay
  setTimeout(() => {
    ftext.style.display = 'none';
    document.getElementById('blood-overlay').style.opacity = '0';
    gameState = 'result';
    showResult(winner);
  }, 4000);
}

function showResult(winner) {
  const overlay = document.getElementById('overlay');
  overlay.innerHTML = `
    <h1>ğŸ† ${winner.data.name} ìŠ¹ë¦¬!</h1>
    <h2>${winner.data.weapon} â€” HP ${Math.floor(winner.hp)}/${winner.maxHp}</h2>
    <div style="margin:20px 0">
      <img src="${ASSET_BASE}${winner.data.id}/idle.png" style="width:128px;height:128px;image-rendering:pixelated">
    </div>
    <button id="start-btn" onclick="location.reload()" style="padding:12px 40px;font-size:18px;font-family:'NeoDGM',monospace;background:#D24C59;color:#FCC88E;border:2px solid #9D7F33;cursor:pointer">ğŸ”„ ë‹¤ì‹œ ì‹¸ìš°ê¸°</button>
    <div style="margin-top:12px"><a href="/">ğŸƒ í¬ì»¤ ì•„ë ˆë‚˜</a></div>
  `;
  overlay.classList.remove('hidden');
}

// Draw floor
function drawFloor() {
  // Dark arena floor with grid
  ctx.fillStyle = '#0a0f1a';
  ctx.fillRect(0, 0, 800, 500);

  // Arena circle
  ctx.save();
  ctx.globalAlpha = 0.15;
  ctx.strokeStyle = '#9D7F33';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.ellipse(400, 340, 300, 120, 0, 0, Math.PI * 2);
  ctx.stroke();
  ctx.globalAlpha = 0.05;
  ctx.fillStyle = '#9D7F33';
  ctx.fill();
  ctx.restore();

  // Blood stains on floor (accumulate during fight)
  ctx.save();
  ctx.globalAlpha = 0.1;
  particles.filter(p => p.life <= 0 && p.gravity).forEach(p => {
    ctx.fillStyle = '#4D2C2C';
    ctx.beginPath();
    ctx.arc(p.x, p.y + 50, p.size * 0.5, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.restore();
}

// Main game loop
function gameLoop() {
  tick++;
  ctx.clearRect(0, 0, 800, 500);

  // Screen shake
  if (shakeDur > 0) {
    shakeX = (Math.random() - 0.5) * shakeDur;
    shakeY = (Math.random() - 0.5) * shakeDur;
    shakeDur--;
  } else {
    shakeX = 0; shakeY = 0;
  }
  ctx.save();
  ctx.translate(shakeX, shakeY);

  drawFloor();

  if (gameState === 'fighting' || gameState === 'fatality' || gameState === 'result') {
    // AI decisions (every N ticks based on speed)
    if (gameState === 'fighting') {
      if (tick % Math.max(5, 20 - p1.spd) === 0) {
        const act = aiDecide(p1, p2);
        executeAction(p1, p2, act);
      }
      if (tick % Math.max(5, 20 - p2.spd) === 0) {
        const act = aiDecide(p2, p1);
        executeAction(p2, p1, act);
      }

      // Check death
      if (p1.hp <= 0 && !p1.dead) {
        p1.hp = 0;
        updateHUD();
        triggerFatality(p2, p1);
      }
      if (p2.hp <= 0 && !p2.dead) {
        p2.hp = 0;
        updateHUD();
        triggerFatality(p1, p2);
      }
    }

    p1.update();
    p2.update();

    // Draw (y-sort)
    const sorted = [p1, p2].sort((a, b) => a.y - b.y);
    sorted.forEach(f => f.draw(ctx));
  }

  // Particles
  particles.forEach(p => {
    p.x += p.vx || 0;
    p.y += p.vy || 0;
    if (p.gravity) p.vy += p.gravity;
    p.life--;
    if (p.life > 0) {
      ctx.save();
      ctx.globalAlpha = Math.min(1, p.life / 15);
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x, p.y, p.size, p.size);
      ctx.restore();
    }
  });
  particles = particles.filter(p => p.life > 0);

  // Damage texts
  dmgTexts.forEach(d => {
    d.y += d.vy;
    d.life--;
    if (d.life > 0) {
      ctx.save();
      ctx.globalAlpha = Math.min(1, d.life / 20);
      ctx.font = 'bold 16px NeoDGM, monospace';
      ctx.fillStyle = d.color;
      ctx.textAlign = 'center';
      ctx.fillText(d.text, d.x, d.y);
      ctx.restore();
    }
  });
  dmgTexts.splice(0, dmgTexts.length, ...dmgTexts.filter(d => d.life > 0));

  ctx.restore();
  requestAnimationFrame(gameLoop);
}

// Start
async function startFight() {
  document.getElementById('overlay').classList.add('hidden');
  document.getElementById('fight-msg').textContent = 'ë¡œë”© ì¤‘...';

  // Random matchup
  const shuffled = [...FIGHTERS].sort(() => Math.random() - 0.5);
  const f1 = shuffled[0], f2 = shuffled[1];

  // Preload
  await Promise.all([preloadFighter(f1), preloadFighter(f2)]);

  p1 = new Fighter(f1, 'left');
  p2 = new Fighter(f2, 'right');

  document.getElementById('p1-name').textContent = f1.name;
  document.getElementById('p2-name').textContent = f2.name;
  document.getElementById('p1-name').style.color = f1.color;
  document.getElementById('p2-name').style.color = f2.color;
  updateHUD();

  // Countdown
  document.getElementById('fight-msg').textContent = 'READY...';
  await new Promise(r => setTimeout(r, 1000));
  document.getElementById('fight-msg').textContent = 'âš”ï¸ FIGHT!';

  gameState = 'fighting';
}

// Init matchup preview
function initMenu() {
  const shuffled = [...FIGHTERS].sort(() => Math.random() - 0.5);
  document.getElementById('mu-p1-img').src = ASSET_BASE + shuffled[0].id + '/idle.png';
  document.getElementById('mu-p2-img').src = ASSET_BASE + shuffled[1].id + '/idle.png';
  document.getElementById('mu-p1-name').textContent = shuffled[0].name;
  document.getElementById('mu-p2-name').textContent = shuffled[1].name;
}

initMenu();
gameLoop();
</script>
</body>
</html>
