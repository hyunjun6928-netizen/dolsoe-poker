<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>‚öîÔ∏è AI ÏΩúÎ°úÏÑ∏ÏõÄ ‚Äî PIXEL DEATH ARENA</title>
<style>
@font-face{font-family:'NeoDGM';src:url('/static/fonts/neodgm.woff2') format('woff2');font-display:swap}
*{margin:0;padding:0;box-sizing:border-box}
body{background:#000;color:#FCC88E;font-family:'NeoDGM',monospace;overflow:hidden;height:100vh;display:flex;align-items:center;justify-content:center}
canvas{display:block;image-rendering:pixelated;image-rendering:crisp-edges}
</style>
</head>
<body>
<canvas id="G"></canvas>
<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  AI ÏΩúÎ°úÏÑ∏ÏõÄ ‚Äî SAMURAI SHODOWN / KOF STYLE 2D FIGHTING
//  Spectator-only: AI vs AI auto-combat with FATALITY finishers
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const C = document.getElementById('G');
const X = C.getContext('2d');
const W = 800, H = 480;
C.width = W; C.height = H;

function resize() {
  const s = Math.min(innerWidth / W, innerHeight / H);
  C.style.width = (W * s) + 'px';
  C.style.height = (H * s) + 'px';
}
resize();
addEventListener('resize', resize);

// ‚îÄ‚îÄ‚îÄ CONSTANTS ‚îÄ‚îÄ‚îÄ
const GROUND_Y = 390;       // feet position
const CHAR_SCALE = 3.2;     // 64px √ó 3.2 = ~205px on screen
const IDLE_SCALE = 1.6;     // 128px √ó 1.6 = ~205px
const GRAVITY = 0.7;
const STAGE_LEFT = 40;
const STAGE_RIGHT = W - 40;
const ATTACK_RANGE = 160;   // pixel distance to land a hit
const CLOSE_RANGE = 120;

const COL = {
  bg:'#0a0810', hpGreen:'#22cc44', hpYellow:'#ccaa22', hpRed:'#cc2222',
  hpBg:'#331111', gold:'#d4af5a', red:'#D24C59', blue:'#4488cc',
  cream:'#FCC88E', grey:'#938B7B', dark:'#221C20', orange:'#F09858',
  mint:'#35B97D', white:'#ffffff', black:'#000000',
  powBlue:'#2266dd', powFull:'#ff4444',
};

// ‚îÄ‚îÄ‚îÄ FIGHTERS ‚îÄ‚îÄ‚îÄ
const FIGHTERS = [
  {id:'bloodfang',   name:'Î∏îÎü¨ÎìúÌå°',      weapon:'ÎèÑÎÅº',   color:'#cc3333', style:'rush',    atk:18,def:8, spd:12,hp:1000,special:'ÏßÄÏò•Ï∞∏Í≤©',  super:'Î∏îÎü¨ÎìúÎ†àÏù∏'},
  {id:'ironclaw',    name:'ÏïÑÏù¥Ïñ∏ÌÅ¥Î°ú',    weapon:'Ï≤†Ìá¥',   color:'#8888aa', style:'grapple', atk:14,def:16,spd:7, hp:1300,special:'ÏïÑÏù¥Ïñ∏Ïõî',  super:'ÌÅ¨Îü¨ÏÖîÏûÑÌå©Ìä∏'},
  {id:'shadowblade', name:'ÏâêÎèÑÏö∞Î∏îÎ†àÏù¥Îìú',weapon:'ÏåçÎã®Í≤Ä', color:'#33aa77', style:'mixup',   atk:20,def:5, spd:18,hp:850, special:'ÌôòÏòÅÏ∞∏',    super:'Î¨¥ÏòÅÎÇúÎ¨¥'},
  {id:'berserker',   name:'Î≤ÑÏÑúÏª§',        weapon:'Ïπ¥ÌÉÄÎÇò', color:'#dd6633', style:'rush',    atk:22,def:4, spd:16,hp:900, special:'Î∞úÍ¥ëÏ∞∏',    super:'ÏïÑÏàòÎùºÏ∞∏ÏòÅÏßÑ'},
  {id:'bonecrusher', name:'Î≥∏ÌÅ¨Îü¨ÏÖî',      weapon:'Ìï¥Î®∏',   color:'#886644', style:'grapple', atk:17,def:14,spd:5, hp:1250,special:'Ïñ¥Ïä§ÌÄòÏù¥ÌÅ¨',super:'Î©îÌÖåÏò§Ìï¥Î®∏'},
  {id:'venomqueen',  name:'Î≤†ÎÜàÌÄ∏',        weapon:'ÎèÖÍ≤Ä',   color:'#22aa66', style:'zone',    atk:12,def:10,spd:14,hp:950, special:'ÎèÖÎ¨¥Ìôî',    super:'Îç∞Ïä§Î∏îÎ£∏'},
  {id:'hellfire',    name:'Ìó¨ÌååÏù¥Ïñ¥',      weapon:'ÌôîÏóºÍ≤Ä', color:'#ff8833', style:'mixup',   atk:20,def:7, spd:12,hp:950, special:'ÌôîÏóºÏÑ†Ìíç',  super:'Ïù∏ÌéòÎ•¥ÎÖ∏'},
  {id:'frostbite',   name:'ÌîÑÎ°úÏä§Ìä∏Î∞îÏù¥Ìä∏',weapon:'ÎπôÍ≤∞Ï∞Ω', color:'#55aacc', style:'zone',    atk:13,def:12,spd:10,hp:1100,special:'ÎπôÍ≤∞ÏßÑ',    super:'Ï†àÎåÄÏòÅÎèÑ'},
];

const FATALITIES = ['head_off','bisect','explode','impale','spine_rip','dissolve'];
const FATALITY_KR = {head_off:'Ï∞∏Ïàò',bisect:'ÏñëÎã®',explode:'Ìè≠ÏÇ¨',impale:'Í¥ÄÌÜµ',spine_rip:'Ï≤ôÏ∂îÏ†ÅÏ∂ú',dissolve:'Ïö©Ìï¥'};

const ASSET = '/colosseum/assets/';
const imgCache = {};
let totalLoad = 0, loaded = 0;

function loadImg(p) {
  if (imgCache[p]) return Promise.resolve(imgCache[p]);
  totalLoad++;
  return new Promise(res => {
    const img = new Image();
    img.onload = () => { imgCache[p] = img; loaded++; res(img); };
    img.onerror = () => { loaded++; res(null); };
    img.src = p;
  });
}

function preloadFighter(f) {
  const b = ASSET + f.id + '/';
  const ps = [loadImg(b+'idle.png'), loadImg(b+'idle_64.png')];
  for (const a of ['walk','attack','hit','death','victory'])
    for (let i = 0; i < 4; i++) ps.push(loadImg(b+a+'_'+i+'.png'));
  for (const ft of FATALITIES)
    for (let i = 0; i < 4; i++) ps.push(loadImg(b+'fatality_'+ft+'_'+i+'.png'));
  return Promise.all(ps);
}

// ‚îÄ‚îÄ‚îÄ STATE ‚îÄ‚îÄ‚îÄ
let scene = 'title', tick = 0, roundNum = 1, p1Wins = 0, p2Wins = 0;
let p1, p2, f1Data, f2Data;
let announceText = '', announceTimer = 0, announceSize = 52;
let slowmo = 0, flashAlpha = 0, flashColor = '#fff';
let bloodStains = [], particles = [], dmgTexts = [], slashFX = [];
let selectP1 = 0, selectP2 = 1, selectTimer = 0;
let shakeDur = 0, shakeX = 0, shakeY = 0;
let gameTimer = 99;
let timerTick = 0;

// ‚îÄ‚îÄ‚îÄ FIGHTER ‚îÄ‚îÄ‚îÄ
class Fighter {
  constructor(data, side) {
    this.d = data;
    this.side = side;
    this.x = side === 'left' ? 180 : W - 180;
    this.y = GROUND_Y;
    this.vx = 0;
    this.vy = 0;
    this.hp = data.hp;
    this.maxHp = data.hp;
    this.pow = 0;           // 0~100
    this.state = 'idle';
    this.frame = 0;
    this.frameTick = 0;
    this.facing = side === 'left' ? 1 : -1;
    this.cooldown = 0;
    this.hitstun = 0;
    this.blockstun = 0;
    this.comboCount = 0;
    this.airborne = false;
    this.dead = false;
    this.frozen = 0;
    this.poison = 0;
    this.armor = 0;
    this.rage = 0;
    this.fatalType = null;
    this.fatalFrame = 0;
    this.enemy = null;
    this.lastAction = '';
  }

  get alive() { return this.hp > 0 && !this.dead; }
  get canAct() { return this.hitstun <= 0 && this.blockstun <= 0 && this.cooldown <= 0 && this.frozen <= 0 && !this.dead && this.state !== 'fatality' && this.state !== 'death'; }
  get dist() { return Math.abs(this.x - this.enemy.x); }

  faceEnemy() { if (this.enemy) this.facing = this.x < this.enemy.x ? 1 : -1; }

  getImg() {
    const b = ASSET + this.d.id + '/';
    if (this.state === 'fatality')
      return imgCache[b + 'fatality_' + this.fatalType + '_' + Math.min(this.fatalFrame, 3) + '.png'];
    if (this.state === 'idle' || this.state === 'block')
      return imgCache[b + 'idle.png']; // 128px idle for bigger display
    if (this.state === 'walk' || this.state === 'dash')
      return imgCache[b + 'walk_' + (this.frame % 4) + '.png'];
    if (this.state === 'special' || this.state === 'super')
      return imgCache[b + 'attack_' + Math.min(this.frame, 3) + '.png'];
    const st = ['attack','hit','death','victory'].includes(this.state) ? this.state : 'idle';
    if (st === 'idle') return imgCache[b + 'idle.png'];
    return imgCache[b + st + '_' + Math.min(this.frame, 3) + '.png'];
  }

  draw() {
    const img = this.getImg();
    if (!img) return;

    // Use idle (128px) at IDLE_SCALE, animations (64px) at CHAR_SCALE
    const isIdle = (this.state === 'idle' || this.state === 'block');
    const scale = isIdle ? IDLE_SCALE : CHAR_SCALE;
    const drawW = img.width * scale;
    const drawH = img.height * scale;

    const drawY = this.y - (this.airborne ? this.vy * 3 : 0);

    X.save();
    X.translate(this.x, drawY);
    if (this.facing < 0) X.scale(-1, 1);

    // Hit flash
    if (this.state === 'hit' && this.hitstun > 8) {
      X.filter = 'brightness(3)';
    } else if (this.state === 'hit') {
      X.globalAlpha = 0.5 + Math.sin(tick * 1.2) * 0.5;
    }
    // Frozen blue tint
    if (this.frozen > 0) X.filter = 'hue-rotate(180deg) brightness(1.3) saturate(1.5)';
    // Rage red aura
    if (this.rage > 40) {
      X.shadowColor = '#ff2200';
      X.shadowBlur = this.rage * 0.4;
    }
    // Super armor gold
    if (this.armor > 0) {
      X.shadowColor = '#ffdd00';
      X.shadowBlur = 20;
    }
    // Block stance ‚Äî slight lean back
    if (this.state === 'block') {
      X.translate(-this.facing * 8, 0);
    }

    X.drawImage(img, -drawW / 2, -drawH + 10, drawW, drawH);
    X.restore();

    // Ground shadow
    X.save();
    X.globalAlpha = 0.35;
    X.fillStyle = '#000';
    X.beginPath();
    X.ellipse(this.x, GROUND_Y + 8, drawW * 0.3, 6, 0, 0, Math.PI * 2);
    X.fill();
    X.restore();

    // Block shield
    if (this.state === 'block' || this.blockstun > 0) {
      X.save();
      X.globalAlpha = 0.25;
      X.strokeStyle = '#88ccff';
      X.lineWidth = 3;
      X.beginPath();
      X.ellipse(this.x, drawY - drawH / 2, drawW * 0.4, drawH * 0.5, 0, 0, Math.PI * 2);
      X.stroke();
      X.restore();
    }

    // Poison drip
    if (this.poison > 0 && tick % 4 === 0) {
      particles.push({x:this.x+rng(-25,25), y:drawY-rng(30,100), vx:rng(-1,1), vy:1, life:20, color:'#22cc66', size:3});
    }
  }

  update() {
    this.frameTick++;
    if (this.cooldown > 0) this.cooldown--;
    if (this.hitstun > 0) { this.hitstun--; if (this.hitstun === 0 && this.state === 'hit') { this.state = 'idle'; this.frame = 0; } }
    if (this.blockstun > 0) { this.blockstun--; if (this.blockstun === 0 && this.state === 'block') { this.state = 'idle'; this.frame = 0; } }
    if (this.frozen > 0) this.frozen--;
    if (this.armor > 0) this.armor--;

    // Rage (berserker)
    if (this.d.id === 'berserker') this.rage = Math.max(0, ((this.maxHp - this.hp) / this.maxHp) * 100);

    // Poison tick
    if (this.poison > 0 && tick % 50 === 0) {
      this.hp = Math.max(1, this.hp - 15);
      this.poison--;
      spawnDmg(this.x, this.y - 120, 'üß™15', '#22cc66');
    }

    // Anim frames
    const spd = this.state === 'attack' ? 4 : this.state === 'special' ? 6 : this.state === 'super' ? 7 : this.state === 'fatality' ? 10 : this.state === 'hit' ? 4 : this.state === 'death' ? 8 : 8;
    if (this.frameTick >= spd) {
      this.frameTick = 0;
      if (this.state === 'fatality') {
        if (this.fatalFrame < 3) this.fatalFrame++;
      } else if (this.state === 'death') {
        if (this.frame < 3) this.frame++;
      } else if (this.state === 'victory') {
        this.frame = (this.frame + 1) % 4;
      } else if (this.state !== 'idle' && this.state !== 'block' && this.state !== 'hit') {
        this.frame++;
        if (this.frame >= 4) { this.state = 'idle'; this.frame = 0; }
      } else {
        this.frame = (this.frame + 1) % 4;
      }
    }

    // Physics
    if (this.airborne) {
      this.vy -= GRAVITY;
      if (this.vy <= 0) { this.vy = 0; this.airborne = false; }
    }
    this.x += this.vx;
    this.vx *= 0.88;

    // Stage bounds ‚Äî wall bounce
    if (this.x < STAGE_LEFT) { this.x = STAGE_LEFT; this.vx = Math.abs(this.vx) * 0.5; }
    if (this.x > STAGE_RIGHT) { this.x = STAGE_RIGHT; this.vx = -Math.abs(this.vx) * 0.5; }
    // Push apart if overlapping
    if (this.enemy && Math.abs(this.x - this.enemy.x) < 60) {
      const push = this.x < this.enemy.x ? -2 : 2;
      this.x += push;
      this.enemy.x -= push;
    }
    // Gentle center pull when far from center and idle (prevents corner camping)
    if (this.canAct && this.state === 'idle') {
      const center = W / 2;
      const distFromCenter = this.x - center;
      if (Math.abs(distFromCenter) > 250) {
        this.x -= distFromCenter * 0.003;
      }
    }

    if (this.canAct) this.faceEnemy();

    // Combo reset
    if (this.hitstun <= 0 && this.comboCount > 0) this.comboCount = 0;
  }

  takeDamage(dmg, canBlock) {
    if (this.dead) return;
    if (canBlock && this.state === 'block') {
      const chip = Math.floor(dmg * 0.1);
      this.hp -= chip;
      this.blockstun = 12;
      spawnDmg(this.x, this.y - 140, 'GUARD ' + chip, '#88ccff');
      this.pow = Math.min(100, this.pow + 2);
      spawnSpark(this.x + this.facing * 30, this.y - 100, 8, '#88ccff');
      return;
    }
    if (this.armor > 0) {
      this.hp -= Math.floor(dmg * 0.4);
      spawnDmg(this.x, this.y - 150, 'ARMOR', COL.gold);
      return;
    }
    this.hp = Math.max(0, this.hp - dmg);
    this.state = 'hit';
    this.frame = 0;
    this.frameTick = 0;
    this.hitstun = 14;
    this.pow = Math.min(100, this.pow + Math.floor(dmg * 0.06));
  }

  knockback(f) { this.vx = -this.facing * f; }
  launch(v) { this.airborne = true; this.vy = v; }
}

// ‚îÄ‚îÄ‚îÄ UTILS ‚îÄ‚îÄ‚îÄ
function rng(a,b){return a+Math.random()*(b-a)}
function rngInt(a,b){return Math.floor(rng(a,b+1))}
function pick(a){return a[Math.floor(Math.random()*a.length)]}
function spawnDmg(x,y,t,c){dmgTexts.push({x,y,text:t,color:c,life:40,vy:-2.5})}
function spawnBlood(x,y,n){
  for(let i=0;i<n;i++) particles.push({x,y:y+rng(-10,10),vx:rng(-8,8),vy:rng(-10,-2),life:rngInt(25,50),color:Math.random()>.3?'#cc2222':'#661111',size:rng(2,6),grav:0.4});
}
function spawnSpark(x,y,n,c){
  for(let i=0;i<n;i++) particles.push({x,y,vx:rng(-5,5),vy:rng(-6,-1),life:rngInt(8,18),color:c||'#ffffaa',size:rng(1,4),grav:0.2});
}
function addSlash(x, y, big) {
  slashFX.push({x, y, life: big ? 12 : 8, size: big ? 80 : 45, angle: rng(-0.5, 0.5), color: big ? '#ffffff' : '#ffffcc'});
}
function shake(d){shakeDur=d}
function announce(t,dur,sz){announceText=t;announceTimer=dur||90;announceSize=sz||52}
function addBloodStain(x){bloodStains.push({x,y:GROUND_Y+6,r:rng(4,12)});if(bloodStains.length>30)bloodStains.shift()}

// ‚îÄ‚îÄ‚îÄ STAGE BACKGROUND ‚îÄ‚îÄ‚îÄ
function drawStage() {
  // Dark stone arena background
  const grd = X.createLinearGradient(0, 0, 0, H);
  grd.addColorStop(0, '#1a0a1a');
  grd.addColorStop(0.4, '#120818');
  grd.addColorStop(0.7, '#0a0610');
  grd.addColorStop(1, '#050308');
  X.fillStyle = grd;
  X.fillRect(0, 0, W, H);

  // Back wall with pillars
  X.save();
  // Stone wall texture
  X.fillStyle = '#0f0a14';
  X.fillRect(0, 0, W, GROUND_Y - 40);

  // Pillars
  for (const px of [60, 200, W-200, W-60]) {
    X.fillStyle = '#1a1020';
    X.fillRect(px - 18, 20, 36, GROUND_Y - 50);
    X.fillStyle = '#231830';
    X.fillRect(px - 14, 20, 28, GROUND_Y - 50);
    // Pillar cap
    X.fillStyle = '#2a1e35';
    X.fillRect(px - 22, 15, 44, 15);
    X.fillRect(px - 22, GROUND_Y - 35, 44, 10);
    // Torch flame
    const flicker = Math.sin(tick * 0.08 + px) * 4;
    X.fillStyle = `rgba(255,${140+flicker*3},50,${0.7+Math.sin(tick*0.12+px)*0.2})`;
    X.beginPath();
    X.ellipse(px, 45 + flicker, 8, 14, 0, 0, Math.PI * 2);
    X.fill();
    // Torch glow
    X.globalAlpha = 0.08 + Math.sin(tick * 0.1 + px) * 0.03;
    X.fillStyle = '#ff8830';
    X.beginPath();
    X.arc(px, 50, 60, 0, Math.PI * 2);
    X.fill();
    X.globalAlpha = 1;
  }

  // Red banners
  for (const bx of [130, W-130]) {
    X.fillStyle = '#881122';
    X.fillRect(bx - 15, 30, 30, 140);
    X.fillStyle = '#aa1533';
    X.fillRect(bx - 11, 34, 22, 132);
    // Banner symbol
    X.fillStyle = '#cc9933';
    X.font = '16px NeoDGM, monospace';
    X.textAlign = 'center';
    X.fillText('‚öî', bx, 100);
  }

  // Center throne/statue silhouette
  X.fillStyle = '#16101e';
  X.fillRect(W/2 - 50, 40, 100, 150);
  X.fillStyle = '#1e1428';
  X.fillRect(W/2 - 40, 50, 80, 130);
  X.fillStyle = '#cc9933';
  X.globalAlpha = 0.6;
  X.font = '28px NeoDGM, monospace';
  X.textAlign = 'center';
  X.fillText('KO', W/2, 130);
  X.globalAlpha = 1;

  X.restore();

  // Ground / floor
  X.fillStyle = '#1a1225';
  X.fillRect(0, GROUND_Y - 30, W, H - GROUND_Y + 40);
  // Stone floor tiles
  X.strokeStyle = '#231830';
  X.lineWidth = 1;
  for (let gx = 0; gx < W; gx += 40) {
    X.beginPath(); X.moveTo(gx, GROUND_Y - 30); X.lineTo(gx, H); X.stroke();
  }
  for (let gy = GROUND_Y - 30; gy < H; gy += 25) {
    X.beginPath(); X.moveTo(0, gy); X.lineTo(W, gy); X.stroke();
  }

  // Ground line highlight
  X.strokeStyle = '#332244';
  X.lineWidth = 2;
  X.beginPath(); X.moveTo(0, GROUND_Y - 28); X.lineTo(W, GROUND_Y - 28); X.stroke();

  // Blood stains on floor
  X.save();
  X.globalAlpha = 0.2;
  bloodStains.forEach(b => {
    X.fillStyle = '#440808';
    X.beginPath(); X.ellipse(b.x, b.y, b.r, b.r * 0.3, 0, 0, Math.PI * 2); X.fill();
  });
  X.restore();
}

// ‚îÄ‚îÄ‚îÄ HUD (Samurai Shodown style) ‚îÄ‚îÄ‚îÄ
function drawHUD() {
  if (!p1 || !p2) return;
  const barW = 310, barH = 18, barY = 22, barGap = 35;

  // Background bar panels
  X.fillStyle = 'rgba(0,0,0,0.6)';
  X.fillRect(0, 0, W, 60);

  // P1 HP bar (right-to-left fill, left side)
  const p1x = W/2 - barGap;
  drawHP(p1x - barW, barY, barW, barH, p1.hp, p1.maxHp, true, p1.d.color);

  // P2 HP bar (left-to-right fill, right side)
  const p2x = W/2 + barGap;
  drawHP(p2x, barY, barW, barH, p2.hp, p2.maxHp, false, p2.d.color);

  // Names
  X.font = '16px NeoDGM, monospace';
  X.textAlign = 'left';
  X.fillStyle = '#ffffff';
  X.fillText(p1.d.name, 12, barY - 2);
  X.textAlign = 'right';
  X.fillText(p2.d.name, W - 12, barY - 2);

  // Timer
  X.textAlign = 'center';
  X.font = '28px NeoDGM, monospace';
  X.fillStyle = gameTimer > 20 ? COL.cream : COL.red;
  X.fillText(String(gameTimer).padStart(2, '0'), W/2, barY + 14);

  // Round / Win marks
  X.font = '10px NeoDGM, monospace';
  X.fillStyle = COL.grey;
  X.textAlign = 'left';
  X.fillText('R' + roundNum, W/2 - 10, barY + 28);

  // Win dots
  for (let i = 0; i < p1Wins; i++) { X.fillStyle = COL.red; X.beginPath(); X.arc(15 + i * 14, barY + barH + 8, 4, 0, Math.PI*2); X.fill(); }
  for (let i = 0; i < p2Wins; i++) { X.fillStyle = COL.red; X.beginPath(); X.arc(W - 15 - i * 14, barY + barH + 8, 4, 0, Math.PI*2); X.fill(); }

  // POW gauges at bottom
  const powY = H - 28, powW = 160, powH = 10;
  // P1
  X.fillStyle = '#111';
  X.fillRect(12, powY, powW, powH);
  X.fillStyle = p1.pow >= 100 ? COL.powFull : COL.powBlue;
  X.fillRect(12, powY, powW * (p1.pow / 100), powH);
  X.strokeStyle = '#444'; X.strokeRect(12, powY, powW, powH);
  X.font = '10px NeoDGM, monospace';
  X.fillStyle = p1.pow >= 100 ? '#ff4444' : '#4488cc';
  X.textAlign = 'left';
  X.fillText('POW', 12, powY - 3);
  if (p1.pow >= 100) { X.fillStyle = '#ff4444'; X.fillText('MAX!', 60, powY - 3); }

  // P2
  X.fillStyle = '#111';
  X.fillRect(W - 12 - powW, powY, powW, powH);
  X.fillStyle = p2.pow >= 100 ? COL.powFull : COL.powBlue;
  X.fillRect(W - 12 - powW, powY, powW * (p2.pow / 100), powH);
  X.strokeStyle = '#444'; X.strokeRect(W - 12 - powW, powY, powW, powH);
  X.textAlign = 'right';
  X.fillStyle = p2.pow >= 100 ? '#ff4444' : '#4488cc';
  X.fillText('POW', W - 12, powY - 3);
  if (p2.pow >= 100) { X.fillStyle = '#ff4444'; X.fillText('MAX!', W - 60, powY - 3); }

  // Combo display
  if (p1.comboCount >= 2) { X.font = '22px NeoDGM, monospace'; X.fillStyle = COL.orange; X.textAlign = 'left'; X.fillText(p1.comboCount + ' HITS!', 15, H/2); }
  if (p2.comboCount >= 2) { X.font = '22px NeoDGM, monospace'; X.fillStyle = COL.orange; X.textAlign = 'right'; X.fillText(p2.comboCount + ' HITS!', W - 15, H/2); }
}

function drawHP(x, y, w, h, hp, max, rtl, color) {
  X.fillStyle = COL.hpBg;
  X.fillRect(x, y, w, h);
  const pct = Math.max(0, hp / max);
  const fw = w * pct;
  const c = pct > 0.5 ? COL.hpGreen : pct > 0.25 ? COL.hpYellow : COL.hpRed;
  // Yellow "damage" bar (slightly wider, fading)
  if (rtl) {
    X.fillStyle = c;
    X.fillRect(x + w - fw, y, fw, h);
  } else {
    X.fillStyle = c;
    X.fillRect(x, y, fw, h);
  }
  // Border
  X.strokeStyle = '#555';
  X.lineWidth = 2;
  X.strokeRect(x, y, w, h);
  // Ticks
  X.strokeStyle = '#333';
  X.lineWidth = 1;
  for (let i = 1; i < 10; i++) {
    const tx = x + (w / 10) * i;
    X.beginPath(); X.moveTo(tx, y); X.lineTo(tx, y + h); X.stroke();
  }
}

// ‚îÄ‚îÄ‚îÄ EFFECTS ‚îÄ‚îÄ‚îÄ
function drawParticles() {
  particles.forEach(p => {
    p.x += p.vx; p.y += p.vy; if (p.grav) p.vy += p.grav; p.life--;
    if (p.life > 0) {
      X.save(); X.globalAlpha = Math.min(1, p.life / 10);
      X.fillStyle = p.color;
      X.fillRect(~~p.x, ~~p.y, ~~p.size, ~~p.size);
      X.restore();
    }
  });
  particles = particles.filter(p => p.life > 0);
}

function drawDmgTexts() {
  dmgTexts.forEach(d => {
    d.y += d.vy; d.life--;
    if (d.life > 0) {
      X.save(); X.globalAlpha = Math.min(1, d.life / 15);
      X.font = 'bold 16px NeoDGM, monospace';
      X.fillStyle = d.color; X.textAlign = 'center';
      X.shadowColor = '#000'; X.shadowBlur = 4;
      X.fillText(d.text, ~~d.x, ~~d.y);
      X.restore();
    }
  });
  dmgTexts = dmgTexts.filter(d => d.life > 0);
}

function drawSlashFX() {
  slashFX.forEach(s => {
    s.life--;
    if (s.life > 0) {
      X.save();
      X.translate(s.x, s.y);
      X.rotate(s.angle);
      X.globalAlpha = s.life / 12;
      X.strokeStyle = s.color;
      X.lineWidth = 3;
      X.shadowColor = s.color;
      X.shadowBlur = 10;
      // Slash arc
      const sz = s.size * (1 - s.life / 12 * 0.3);
      X.beginPath();
      X.arc(0, 0, sz, -0.4, 0.4);
      X.stroke();
      X.beginPath();
      X.moveTo(-sz * 0.8, -sz * 0.3);
      X.lineTo(sz * 0.8, sz * 0.1);
      X.stroke();
      X.restore();
    }
  });
  slashFX = slashFX.filter(s => s.life > 0);
}

function drawAnnounce() {
  if (announceTimer <= 0) return;
  announceTimer--;
  X.save();
  const alpha = Math.min(1, announceTimer / 12);
  X.globalAlpha = alpha;
  X.font = announceSize + 'px NeoDGM, monospace';
  X.textAlign = 'center';
  // Outline
  X.strokeStyle = '#000';
  X.lineWidth = 5;
  X.strokeText(announceText, W/2, H/2 - 30);
  // Fill
  X.fillStyle = announceSize > 48 ? COL.red : COL.gold;
  X.shadowColor = announceSize > 48 ? '#ff0000' : '#ffaa00';
  X.shadowBlur = 25;
  X.fillText(announceText, W/2, H/2 - 30);
  X.restore();
}

function drawFlash() {
  if (flashAlpha > 0) {
    X.save(); X.globalAlpha = flashAlpha;
    X.fillStyle = flashColor;
    X.fillRect(0, 0, W, H);
    X.restore();
    flashAlpha -= 0.06;
  }
}

// ‚îÄ‚îÄ‚îÄ AI ‚îÄ‚îÄ‚îÄ
function aiBrain(me, foe) {
  if (!me.canAct) return null;
  const d = me.dist;
  const r = Math.random();
  const style = me.d.style;

  // NEVER attack if out of range ‚Äî always walk/dash first
  const inRange = d <= ATTACK_RANGE;
  const midRange = d > ATTACK_RANGE && d <= 300;
  const farRange = d > 300;

  // Combo extend ‚Äî only if in range and foe stunned
  if (inRange && foe.hitstun > 4) {
    return r < 0.8 ? 'attack' : (me.pow >= 30 ? 'special' : 'attack');
  }

  // Super ‚Äî only when in range
  if (inRange && me.pow >= 100 && r < 0.5) return 'super';
  // Special ‚Äî only when close
  if (inRange && me.pow >= 30 && r < 0.2) return 'special';

  // OUT OF RANGE ‚Äî must approach
  if (farRange) return r < 0.5 ? 'dash' : 'walk';
  if (midRange) {
    if (style === 'rush') return r < 0.6 ? 'dash' : 'walk';
    if (style === 'grapple') return r < 0.7 ? 'walk' : 'block';
    if (style === 'zone') return r < 0.4 ? 'walk' : r < 0.7 ? 'block' : 'walk';
    return r < 0.5 ? 'dash' : 'walk';
  }

  // IN RANGE ‚Äî fight!
  switch(style) {
    case 'rush':    return r < 0.55 ? 'attack' : r < 0.75 ? 'special' : 'attack';
    case 'grapple': return r < 0.5 ? 'attack' : r < 0.7 ? 'block' : 'special';
    case 'mixup':   return pick(['attack','attack','special','back','attack']);
    case 'zone':    return r < 0.4 ? 'attack' : r < 0.6 ? 'special' : 'back';
  }
  return r < 0.6 ? 'attack' : 'block';
}

function execAction(me, foe, act) {
  if (!act || !me.canAct) return;
  me.faceEnemy();
  me.lastAction = act;

  switch(act) {
    case 'walk':
      me.vx = me.facing * 3.5;
      me.state = 'walk'; me.frame = 0;
      me.cooldown = 5;
      break;
    case 'back':
      me.vx = -me.facing * 5;
      me.cooldown = 10;
      break;
    case 'dash':
      me.vx = me.facing * 10;
      me.state = 'dash'; me.frame = 0;
      me.cooldown = 16;
      break;
    case 'block':
      me.state = 'block'; me.cooldown = 18;
      setTimeout(() => { if (me.state === 'block') { me.state = 'idle'; me.frame = 0; } }, 600);
      break;
    case 'attack': doAttack(me, foe); break;
    case 'special': doSpecial(me, foe); break;
    case 'super': doSuper(me, foe); break;
  }
}

function doAttack(me, foe) {
  me.state = 'attack'; me.frame = 0; me.frameTick = 0;
  me.cooldown = Math.max(10, 28 - me.d.spd);
  setTimeout(() => {
    if (!foe.alive || me.dead) return;
    if (me.dist > ATTACK_RANGE + 20) return; // silently miss if too far ‚Äî no MISS spam
    if (Math.random() < foe.d.spd * 0.004) { spawnDmg(foe.x, foe.y - 120, 'DODGE', '#44ccff'); return; }

    let dmg = me.d.atk * 3 + rngInt(-5, 10);
    if (me.rage > 40) dmg += Math.floor(me.rage * 0.3);
    const crit = Math.random() < 0.1;
    if (crit) dmg = Math.floor(dmg * 2);
    if (foe.hitstun > 0) { me.comboCount++; dmg = Math.floor(dmg * Math.max(0.4, 1 - me.comboCount * 0.1)); }
    dmg = Math.max(5, Math.floor(dmg - foe.d.def * 0.8));

    foe.takeDamage(dmg, true);
    foe.knockback(5 + (crit ? 4 : 0));
    me.pow = Math.min(100, me.pow + 4);

    const hx = (me.x + foe.x) / 2;
    const hy = GROUND_Y - 100;
    addSlash(hx, hy, crit);
    spawnDmg(foe.x, foe.y - 140, (crit ? 'üí•' : '') + dmg, crit ? COL.orange : COL.red);
    spawnBlood(hx, hy, crit ? 20 : 8);
    spawnSpark(hx, hy, 6, '#ffffaa');
    addBloodStain(foe.x);
    shake(crit ? 8 : 4);
  }, 120);
}

function doSpecial(me, foe) {
  if (me.pow < 30) { doAttack(me, foe); return; }
  me.pow -= 30;
  me.state = 'special'; me.frame = 0; me.frameTick = 0;
  me.cooldown = 32;
  flashAlpha = 0.3; flashColor = me.d.color;
  spawnDmg(me.x, me.y - 170, '‚ú®' + me.d.special, me.d.color);

  setTimeout(() => {
    if (!foe.alive || me.dead) return;
    if (me.dist > 200) return;
    let dmg = Math.floor(me.d.atk * 4.5) + rngInt(0, 15);
    dmg = Math.max(10, Math.floor(dmg - foe.d.def * 0.5));

    if (me.d.id === 'venomqueen') { foe.poison += 4; spawnDmg(foe.x, foe.y-130, 'üß™ÎèÖ!', '#22cc66'); }
    if (me.d.id === 'frostbite') { foe.frozen = 40; spawnDmg(foe.x, foe.y-130, 'üßäÎπôÍ≤∞!', '#55aacc'); }
    if (me.d.id === 'ironclaw' || me.d.id === 'bonecrusher') me.armor = 25;
    if (me.d.id === 'shadowblade') dmg = Math.floor(dmg * 1.4);
    if (me.d.id === 'hellfire') {
      for (let i = 0; i < 25; i++) particles.push({x:foe.x+rng(-40,40),y:GROUND_Y-rng(50,150),vx:rng(-3,3),vy:rng(-4,-1),life:25,color:pick(['#ff6622','#ff3300','#ffcc00']),size:rng(3,6),grav:-0.1});
    }
    if (me.d.id === 'berserker') dmg += Math.floor(me.rage * 0.4);

    foe.takeDamage(dmg, true);
    foe.knockback(8);
    foe.launch(5);
    const hx = (me.x + foe.x) / 2;
    addSlash(hx, GROUND_Y - 100, true);
    spawnBlood(foe.x, GROUND_Y - 100, 18);
    shake(10);
    slowmo = 10;
  }, 180);
}

function doSuper(me, foe) {
  if (me.pow < 100) { doSpecial(me, foe); return; }
  me.pow = 0;
  me.state = 'super'; me.frame = 0; me.frameTick = 0;
  me.cooldown = 50;
  me.armor = 35;
  flashAlpha = 1.0; flashColor = '#ffffff';
  slowmo = 25;
  announce(me.d.super + '!!', 70, 38);

  setTimeout(() => {
    if (!foe.alive || me.dead) return;
    if (me.dist > 250) return;
    let dmg = Math.floor(me.d.atk * 7) + rngInt(5, 25);
    dmg = Math.max(20, Math.floor(dmg - foe.d.def * 0.3));
    foe.takeDamage(dmg, false);
    foe.knockback(12);
    foe.launch(8);

    const hx = (me.x + foe.x) / 2;
    addSlash(hx, GROUND_Y - 120, true);
    addSlash(hx + 30, GROUND_Y - 80, true);
    spawnBlood(foe.x, GROUND_Y - 100, 40);
    for (let i = 0; i < 30; i++) particles.push({x:rng(100,700),y:rng(100,350),vx:rng(-2,2),vy:rng(-3,1),life:30,color:me.d.color,size:rng(2,7),grav:0.1});
    spawnDmg(foe.x, foe.y - 160, 'üíÄ' + dmg, COL.gold);
    shake(18);
  }, 300);
}

// ‚îÄ‚îÄ‚îÄ FATALITY ‚îÄ‚îÄ‚îÄ
function triggerFatality(winner, loser) {
  scene = 'fatality';
  const ft = pick(FATALITIES);
  loser.state = 'fatality'; loser.fatalType = ft; loser.fatalFrame = 0; loser.dead = true;
  flashAlpha = 1.0; flashColor = '#ff0000';
  slowmo = 35; shake(25);
  spawnBlood(loser.x, GROUND_Y - 100, 80);
  announce('üíÄ FATALITY ‚Äî ' + FATALITY_KR[ft] + ' üíÄ', 120, 42);
  setTimeout(() => { winner.state = 'victory'; winner.frame = 0; }, 1500);
  setTimeout(() => {
    if (winner === p1) p1Wins++; else p2Wins++;
    goNextRound();
  }, 4000);
}

function goNextRound() {
  if (p1Wins >= 2 || p2Wins >= 2) { scene = 'result'; return; }
  roundNum++;
  [p1, p2].forEach((f, i) => {
    f.hp = f.maxHp; f.pow = 0; f.dead = false; f.state = 'idle'; f.frame = 0;
    f.x = i === 0 ? 180 : W - 180;
    f.vy = 0; f.vx = 0; f.airborne = false; f.poison = 0; f.frozen = 0; f.comboCount = 0;
  });
  bloodStains = []; particles = []; dmgTexts = []; slashFX = [];
  introTimer = 0; gameTimer = 99; timerTick = 0;
  scene = 'intro';
}

// ‚îÄ‚îÄ‚îÄ SCENES ‚îÄ‚îÄ‚îÄ
function drawTitle() {
  drawStage();
  X.save(); X.textAlign = 'center';
  X.fillStyle = 'rgba(0,0,0,0.6)'; X.fillRect(0, 0, W, H);
  X.font = '48px NeoDGM, monospace'; X.fillStyle = COL.red;
  X.shadowColor = '#ff0000'; X.shadowBlur = 25;
  X.fillText('‚öîÔ∏è AI ÏΩúÎ°úÏÑ∏ÏõÄ', W/2, 150);
  X.shadowBlur = 0;
  X.font = '20px NeoDGM, monospace'; X.fillStyle = COL.cream;
  X.fillText('PIXEL DEATH ARENA', W/2, 185);
  X.font = '13px NeoDGM, monospace'; X.fillStyle = COL.gold;
  X.fillText('AI vs AI ÏûêÎèô Ï†ÑÌà¨ ¬∑ Í¥ÄÏ†Ñ Ï†ÑÏö© ¬∑ 3ÎùºÏö¥Îìú 2ÏÑ†Ïäπ ¬∑ Í≥†Ïñ¥', W/2, 215);

  // Showcase
  const idx = Math.floor(tick / 80) % FIGHTERS.length;
  const sf = FIGHTERS[idx];
  const img = imgCache[ASSET + sf.id + '/idle.png'];
  if (img) { X.save(); X.globalAlpha = .7+Math.sin(tick*.03)*.3; X.drawImage(img, W/2-80, 240, 160, 160); X.restore(); }
  X.font = '14px NeoDGM, monospace'; X.fillStyle = sf.color;
  X.fillText(sf.name + ' ‚Äî ' + sf.weapon, W/2, 420);

  if (~~(tick/25)%2===0) { X.font = '18px NeoDGM, monospace'; X.fillStyle = COL.cream; X.fillText('[ ÌÅ¥Î¶≠ÌïòÏó¨ ÏãúÏûë ]', W/2, 455); }
  X.restore();
}

function drawSelect() {
  drawStage();
  X.fillStyle = 'rgba(0,0,0,0.7)'; X.fillRect(0, 0, W, H);
  X.save(); X.textAlign = 'center';
  X.font = '22px NeoDGM, monospace'; X.fillStyle = COL.gold; X.fillText('‚öîÔ∏è FIGHTER SELECT', W/2, 35);
  const cols = 4, cw = 180, ch = 170, sx = (W-cols*cw)/2, sy = 50;
  FIGHTERS.forEach((f, i) => {
    const c = i%cols, r = Math.floor(i/cols);
    const cx = sx+c*cw+cw/2, cy = sy+r*ch+ch/2;
    const isP1 = i===selectP1, isP2 = i===selectP2;
    if (isP1||isP2) {
      X.save(); X.strokeStyle = isP1?COL.red:'#4488cc'; X.lineWidth = 2;
      X.shadowColor = isP1?COL.red:'#4488cc'; X.shadowBlur = 12;
      X.strokeRect(cx-cw/2+8, cy-ch/2+4, cw-16, ch-8); X.restore();
      X.font = '11px NeoDGM, monospace'; X.fillStyle = isP1?COL.red:'#4488cc';
      X.fillText(isP1?'1P':'2P', cx, cy-ch/2+16);
    }
    const img = imgCache[ASSET+f.id+'/idle.png'];
    if (img) X.drawImage(img, cx-45, cy-50, 90, 90);
    X.font = '12px NeoDGM, monospace'; X.fillStyle = f.color; X.fillText(f.name, cx, cy+52);
    X.font = '9px NeoDGM, monospace'; X.fillStyle = COL.grey; X.fillText(f.weapon+' ATK:'+f.atk+' SPD:'+f.spd, cx, cy+66);
  });
  selectTimer++;
  if (selectTimer > 100) startMatch();
  X.font = '14px NeoDGM, monospace'; X.fillStyle = COL.cream;
  X.fillText(FIGHTERS[selectP1].name+'  ‚öîÔ∏è  '+FIGHTERS[selectP2].name, W/2, H-25);
  X.font = '10px NeoDGM, monospace'; X.fillStyle = COL.grey; X.fillText('ÏûêÎèô ÏÑ†ÌÉù Ï§ë...', W/2, H-10);
  X.restore();
}

let introTimer = 0;
function drawIntro() {
  drawStage();
  if (p1) p1.draw(); if (p2) p2.draw();
  drawHUD();
  introTimer++;
  X.save(); X.textAlign = 'center';
  if (introTimer < 50) {
    X.font = '40px NeoDGM, monospace'; X.fillStyle = COL.gold;
    X.strokeStyle = '#000'; X.lineWidth = 4; X.strokeText('ROUND '+roundNum, W/2, H/2-30);
    X.shadowColor = COL.gold; X.shadowBlur = 15; X.fillText('ROUND '+roundNum, W/2, H/2-30);
  } else if (introTimer < 85) {
    X.font = '56px NeoDGM, monospace'; X.fillStyle = COL.red;
    X.strokeStyle = '#000'; X.lineWidth = 5; X.strokeText('FIGHT!', W/2, H/2-20);
    X.shadowColor = '#ff0000'; X.shadowBlur = 25; X.fillText('FIGHT!', W/2, H/2-20);
  } else { scene = 'fighting'; tick = 0; timerTick = 0; }
  X.restore();
}

function drawResult() {
  drawStage();
  if (p1) p1.draw(); if (p2) p2.draw();
  drawParticles();
  X.fillStyle = 'rgba(0,0,0,0.65)'; X.fillRect(0, 0, W, H);
  X.save(); X.textAlign = 'center';
  const w = p1Wins >= 2 ? p1 : p2;
  X.font = '40px NeoDGM, monospace'; X.fillStyle = COL.gold;
  X.shadowColor = COL.gold; X.shadowBlur = 20;
  X.fillText('üèÜ '+w.d.name+' ÏäπÎ¶¨!', W/2, 130); X.shadowBlur = 0;
  X.font = '18px NeoDGM, monospace'; X.fillStyle = COL.cream;
  X.fillText(w.d.weapon+' | '+p1Wins+' ‚Äî '+p2Wins, W/2, 165);
  const img = imgCache[ASSET+w.d.id+'/idle.png'];
  if (img) X.drawImage(img, W/2-80, 190, 160, 160);
  if (~~(tick/25)%2===0) { X.font = '18px NeoDGM, monospace'; X.fillStyle = COL.cream; X.fillText('[ ÌÅ¥Î¶≠ÌïòÏó¨ Ïû¨ÏãúÏûë ]', W/2, 400); }
  X.restore();
}

// ‚îÄ‚îÄ‚îÄ MAIN LOOP ‚îÄ‚îÄ‚îÄ
function loop() {
  tick++;
  if (slowmo > 0) { slowmo--; if (tick % 3 !== 0) { requestAnimationFrame(loop); return; } }

  X.clearRect(0, 0, W, H);
  if (shakeDur > 0) { shakeX = (Math.random()-.5)*shakeDur*.8; shakeY = (Math.random()-.5)*shakeDur*.8; shakeDur--; } else { shakeX=0; shakeY=0; }
  X.save(); X.translate(shakeX, shakeY);

  switch(scene) {
    case 'title': drawTitle(); break;
    case 'select': drawSelect(); break;
    case 'loading':
      X.fillStyle = '#000'; X.fillRect(0,0,W,H);
      X.textAlign = 'center'; X.font = '16px NeoDGM, monospace'; X.fillStyle = COL.cream;
      X.fillText('Î°úÎî© Ï§ë... '+loaded+'/'+totalLoad, W/2, H/2);
      X.fillStyle = '#222'; X.fillRect(W/2-150, H/2+15, 300, 12);
      X.fillStyle = COL.gold; X.fillRect(W/2-150, H/2+15, 300*(loaded/Math.max(1,totalLoad)), 12);
      break;
    case 'intro': drawIntro(); break;
    case 'fighting':
      drawStage();
      // Timer
      timerTick++;
      if (timerTick >= 60) { timerTick = 0; gameTimer = Math.max(0, gameTimer - 1); }
      // AI
      if (tick % Math.max(8, 22 - p1.d.spd) === 0) execAction(p1, p2, aiBrain(p1, p2));
      if (tick % Math.max(8, 22 - p2.d.spd) === 0) execAction(p2, p1, aiBrain(p2, p1));
      p1.update(); p2.update();
      // Y-sort
      [p1,p2].sort((a,b)=>a.y-b.y).forEach(f=>f.draw());
      drawSlashFX(); drawParticles(); drawDmgTexts(); drawHUD(); drawAnnounce();
      // KO check
      if (p1.hp <= 0 && !p1.dead) {
        p1.hp = 0;
        if (p2.hp === p2.maxHp) announce('PERFECT!', 80, 44);
        if (Math.random() < 0.35) triggerFatality(p2, p1);
        else { p1.state='death';p1.frame=0;p1.dead=true;p2.state='victory';p2.frame=0; announce('K.O.!',80,56);shake(12);flashAlpha=0.7;flashColor='#fff'; setTimeout(()=>{p2Wins++;goNextRound()},3000); }
      }
      if (p2.hp <= 0 && !p2.dead) {
        p2.hp = 0;
        if (p1.hp === p1.maxHp) announce('PERFECT!', 80, 44);
        if (Math.random() < 0.35) triggerFatality(p1, p2);
        else { p2.state='death';p2.frame=0;p2.dead=true;p1.state='victory';p1.frame=0; announce('K.O.!',80,56);shake(12);flashAlpha=0.7;flashColor='#fff'; setTimeout(()=>{p1Wins++;goNextRound()},3000); }
      }
      // Timeout
      if (gameTimer <= 0 && !p1.dead && !p2.dead) {
        announce('TIME UP!', 80, 44);
        const pp1=p1.hp/p1.maxHp, pp2=p2.hp/p2.maxHp;
        if(pp1>pp2){p2.dead=true;p1Wins++}else if(pp2>pp1){p1.dead=true;p2Wins++}else{p1Wins++;p2Wins++}
        setTimeout(()=>goNextRound(),2000);
      }
      break;
    case 'fatality':
      drawStage();
      p1.update();p2.update();
      [p1,p2].sort((a,b)=>a.y-b.y).forEach(f=>f.draw());
      drawSlashFX();drawParticles();drawDmgTexts();drawHUD();drawAnnounce();
      break;
    case 'result': drawResult(); break;
  }
  drawFlash();
  X.restore();
  requestAnimationFrame(loop);
}

async function startMatch() {
  scene = 'loading';
  f1Data = FIGHTERS[selectP1]; f2Data = FIGHTERS[selectP2];
  await Promise.all([preloadFighter(f1Data), preloadFighter(f2Data)]);
  p1 = new Fighter(f1Data, 'left'); p2 = new Fighter(f2Data, 'right');
  p1.enemy = p2; p2.enemy = p1;
  p1Wins=0;p2Wins=0;roundNum=1;gameTimer=99;timerTick=0;
  bloodStains=[];particles=[];dmgTexts=[];slashFX=[];
  introTimer=0; scene='intro';
}

C.addEventListener('click', () => {
  if (scene==='title'||scene==='result') {
    const idx=[...Array(8).keys()].sort(()=>Math.random()-.5);
    selectP1=idx[0];selectP2=idx[1];selectTimer=0;scene='select';
  }
});

Promise.all(FIGHTERS.map(f=>loadImg(ASSET+f.id+'/idle.png')));
loop();
</script>
</body>
</html>
